"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/./context/ZeroTrustContext.tsx":
/*!**************************************!*\
  !*** ./context/ZeroTrustContext.tsx ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ZeroTrustProvider: function() { return /* binding */ ZeroTrustProvider; },\n/* harmony export */   useZeroTrust: function() { return /* binding */ useZeroTrust; },\n/* harmony export */   useZeroTrustSecurity: function() { return /* binding */ useZeroTrustSecurity; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _WebSocketContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./WebSocketContext */ \"(app-pages-browser)/./context/WebSocketContext.tsx\");\n/* harmony import */ var _lib_heuristics_thresholds__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib/heuristics-thresholds */ \"(app-pages-browser)/./lib/heuristics-thresholds.ts\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n// context/ZeroTrustContext.tsx\n/* __next_internal_client_entry_do_not_use__ ZeroTrustProvider,useZeroTrust,useZeroTrustSecurity,default auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$(), _s2 = $RefreshSig$();\n\n\n\nconst ZeroTrustContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\n// Default heuristics matching heuristics.json baseline\nconst DEFAULT_HEURISTICS = {\n    latencyMs: 48.5,\n    entropyAfter: 7.8,\n    memoryPercent: 0.204,\n    cpuPercent: 0.0,\n    hmacFailures: 0,\n    decryptFailures: 0,\n    replayAttempts: 0,\n    malformedPackets: 0,\n    timingAnomalies: 0\n};\nfunction ZeroTrustProvider(param) {\n    let { children } = param;\n    _s();\n    const { lastMessage, sendMessage } = (0,_WebSocketContext__WEBPACK_IMPORTED_MODULE_2__.useWebSocket)();\n    // Core state\n    const [isZeroTrustMode, setIsZeroTrustMode] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [isPasskeyVerified, setIsPasskeyVerified] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // Recipe state\n    // Note: this is UI state; the ESP32 is the source of truth. We reconcile on WS events.\n    const [activeRecipe, setActiveRecipe] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"CHAOS_ONLY\");\n    const [pendingRecipe, setPendingRecipe] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [lastSwitchReason, setLastSwitchReason] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [lastSwitchTime, setLastSwitchTime] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    // Heuristics state\n    const [heuristics, setHeuristics] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(DEFAULT_HEURISTICS);\n    // Alerts state\n    const [alerts, setAlerts] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    // Event logs state\n    const [eventLogs, setEventLogs] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    // Legacy data\n    const [zeroTrustData, setZeroTrustData] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        threatLevel: \"green\"\n    });\n    // Passkey verification\n    const verifyPasskey = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(async (passkey)=>{\n        const correctPasskey = process.env.NEXT_PUBLIC_ZTM_PASSKEY || \"1234\";\n        if (passkey === correctPasskey) {\n            setIsPasskeyVerified(true);\n            addEventLog({\n                type: \"success\",\n                message: \"ZTM passkey verified successfully\",\n                source: \"ztm\"\n            });\n            return true;\n        }\n        addEventLog({\n            type: \"warning\",\n            message: \"Invalid ZTM passkey attempt\",\n            source: \"ztm\"\n        });\n        return false;\n    }, []);\n    // Enable ZTM\n    const enableZeroTrust = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((passkey)=>{\n        console.log(\"[Zero Trust] \\uD83D\\uDE80 Activating Zero Trust Mode...\");\n        // Generate ephemeral session data\n        const sessionKey = Array.from({\n            length: 32\n        }, ()=>Math.floor(Math.random() * 256).toString(16).padStart(2, \"0\")).join(\"\");\n        const words = [\n            \"quantum\",\n            \"lattice\",\n            \"cipher\",\n            \"void\",\n            \"neon\",\n            \"trust\",\n            \"zero\",\n            \"burn\",\n            \"crypto\",\n            \"secure\",\n            \"ghost\",\n            \"shadow\",\n            \"black\",\n            \"red\",\n            \"green\",\n            \"pulse\"\n        ];\n        const ephemeralIdentity = Array.from({\n            length: 4\n        }, ()=>words[Math.floor(Math.random() * words.length)]).join(\"-\");\n        setZeroTrustData({\n            sessionKey,\n            ephemeralIdentity,\n            threatLevel: \"yellow\"\n        });\n        setIsZeroTrustMode(true);\n        // Request baseline recipe; ESP32 will confirm via ztm_activation_acknowledged/ztm_status\n        setPendingRecipe(\"CHAOS_ONLY\");\n        setLastSwitchReason(\"ZTM activation - starting with baseline recipe\");\n        setLastSwitchTime(Date.now());\n        // Send activation to backend\n        // Include passkey for server-side verification (default to '1234' if not provided)\n        const finalPasskey = passkey || process.env.NEXT_PUBLIC_ZTM_PASSKEY || \"1234\";\n        sendMessage({\n            type: \"ztm_activate_request\",\n            passkey: finalPasskey,\n            sessionKey,\n            ephemeralIdentity,\n            initialRecipe: \"CHAOS_ONLY\"\n        });\n        addEventLog({\n            type: \"recipe_switch\",\n            message: \"Zero Trust Mode activated with CHAOS_ONLY baseline\",\n            source: \"ztm\",\n            details: {\n                ephemeralIdentity\n            }\n        });\n        console.log(\"[Zero Trust] ✅ Mode activated with ephemeral identity:\", ephemeralIdentity);\n    }, [\n        sendMessage\n    ]);\n    // Disable ZTM\n    const disableZeroTrust = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        console.log(\"[Zero Trust] \\uD83D\\uDDD1️ Deactivating Zero Trust Mode...\");\n        sendMessage({\n            type: \"ztm_deactivate_request\"\n        });\n        addEventLog({\n            type: \"info\",\n            message: \"Zero Trust Mode deactivated - returning to Normal Mode\",\n            source: \"ztm\"\n        });\n        setZeroTrustData({\n            threatLevel: \"green\"\n        });\n        setIsZeroTrustMode(false);\n        setIsPasskeyVerified(false);\n        setActiveRecipe(\"CHAOS_ONLY\");\n        setPendingRecipe(null);\n        setLastSwitchReason(null);\n        setLastSwitchTime(null);\n        setHeuristics(DEFAULT_HEURISTICS);\n        console.log(\"[Zero Trust] ✅ Mode deactivated, all data destroyed\");\n    }, [\n        sendMessage\n    ]);\n    // Switch recipe\n    const switchRecipe = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((recipe, reason)=>{\n        // Cooldown check (5 seconds minimum)\n        if (lastSwitchTime && Date.now() - lastSwitchTime < 5000) {\n            addEventLog({\n                type: \"warning\",\n                message: \"Recipe switch blocked - cooldown active (5s minimum)\",\n                source: \"ztm\"\n            });\n            return;\n        }\n        const switchReason = reason || \"Manual switch to \".concat(recipe);\n        // Do not immediately claim the recipe is active; wait for ESP32 confirmation\n        setPendingRecipe(recipe);\n        setLastSwitchReason(switchReason);\n        setLastSwitchTime(Date.now());\n        sendMessage({\n            type: \"adaptive_switch_request\",\n            mode: \"ztm\",\n            recipe: recipe.toUpperCase() // Server expects uppercase: CHAOS_ONLY, SALSA_LIGHT, etc.\n        });\n        addEventLog({\n            type: \"recipe_switch\",\n            message: \"Switch requested → \".concat(recipe, \": \").concat(switchReason),\n            source: \"ztm\",\n            details: {\n                recipe,\n                reason: switchReason,\n                pending: true\n            }\n        });\n        console.log(\"[Zero Trust] ⚡ Recipe switched to \".concat(recipe, \": \").concat(switchReason));\n    }, [\n        lastSwitchTime,\n        sendMessage\n    ]);\n    // Update heuristics\n    const updateHeuristics = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((metrics)=>{\n        setHeuristics((prev)=>({\n                ...prev,\n                ...metrics\n            }));\n    }, []);\n    // Track last threshold check to avoid duplicate alerts\n    const lastThresholdCheck = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(0);\n    // Check thresholds on heuristics change - works in BOTH Normal and ZTM modes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const now = Date.now();\n        // Only check every 2 seconds to prevent spam\n        if (now - lastThresholdCheck.current < 2000) return;\n        lastThresholdCheck.current = now;\n        // Check thresholds against current heuristics\n        const triggers = (0,_lib_heuristics_thresholds__WEBPACK_IMPORTED_MODULE_3__.checkThresholds)(heuristics);\n        for (const trigger of triggers){\n            // Check cooldown to prevent duplicate alerts\n            if (!(0,_lib_heuristics_thresholds__WEBPACK_IMPORTED_MODULE_3__.canTriggerAlert)(trigger.profile.name, trigger.profile.cooldownSeconds)) {\n                continue;\n            }\n            // Generate alert (works in both modes)\n            const newAlert = {\n                id: \"alert-\".concat(Date.now(), \"-\").concat(Math.random().toString(36).substr(2, 9)),\n                timestamp: Date.now(),\n                type: trigger.profile.severity,\n                attackType: trigger.profile.displayName,\n                message: trigger.profile.reason,\n                metric: trigger.metric,\n                value: trigger.value,\n                threshold: trigger.threshold,\n                recipe: isZeroTrustMode ? trigger.profile.targetRecipe : undefined\n            };\n            setAlerts((prev)=>[\n                    newAlert,\n                    ...prev\n                ].slice(0, 50));\n            // Log the alert\n            addEventLog({\n                type: \"threat\",\n                message: \"\".concat(trigger.profile.displayName, \": \").concat(trigger.profile.reason),\n                source: isZeroTrustMode ? \"ztm\" : \"system\",\n                details: {\n                    metric: trigger.metric,\n                    value: trigger.value,\n                    threshold: trigger.threshold,\n                    mode: isZeroTrustMode ? \"ZTM\" : \"NORMAL\"\n                }\n            });\n            // Only auto-switch recipe in ZTM mode\n            if (isZeroTrustMode && trigger.profile.targetRecipe) {\n                switchRecipe(trigger.profile.targetRecipe, trigger.profile.reason);\n            }\n            console.log(\"[Alert] \".concat(isZeroTrustMode ? \"\\uD83D\\uDD34 ZTM\" : \"\\uD83D\\uDFE1 Normal\", \": \").concat(trigger.profile.displayName), {\n                metric: trigger.metric,\n                value: trigger.value,\n                threshold: trigger.threshold,\n                autoSwitch: isZeroTrustMode\n            });\n        }\n    }, [\n        heuristics,\n        isZeroTrustMode\n    ]);\n    // Add alert\n    const addAlert = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((alert)=>{\n        const newAlert = {\n            ...alert,\n            id: \"alert-\".concat(Date.now(), \"-\").concat(Math.random().toString(36).substr(2, 9)),\n            timestamp: Date.now()\n        };\n        setAlerts((prev)=>[\n                newAlert,\n                ...prev\n            ].slice(0, 50)) // Keep max 50 alerts\n        ;\n        // Also log to event log\n        addEventLog({\n            type: \"threat\",\n            message: \"\".concat(alert.attackType, \": \").concat(alert.message),\n            source: \"ztm\",\n            details: {\n                metric: alert.metric,\n                value: alert.value,\n                threshold: alert.threshold\n            }\n        });\n    }, []);\n    const dismissAlert = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((id)=>{\n        setAlerts((prev)=>prev.filter((a)=>a.id !== id));\n    }, []);\n    const clearAlerts = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        setAlerts([]);\n    }, []);\n    // Add event log\n    const addEventLog = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((entry)=>{\n        const newEntry = {\n            ...entry,\n            id: \"log-\".concat(Date.now(), \"-\").concat(Math.random().toString(36).substr(2, 9)),\n            timestamp: Date.now()\n        };\n        setEventLogs((prev)=>[\n                ...prev,\n                newEntry\n            ].slice(-100)) // Keep last 100 logs\n        ;\n    }, []);\n    const clearEventLogs = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        setEventLogs([]);\n    }, []);\n    // Listen for WebSocket messages\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!lastMessage) return;\n        const { type, ...data } = lastMessage;\n        switch(type){\n            case \"ztm_activation_acknowledged\":\n                if (data.success) {\n                    setZeroTrustData((prev)=>({\n                            ...prev,\n                            threatLevel: \"green\"\n                        }));\n                    // Prefer ESP32-provided recipe fields (currentRecipe/recipe)\n                    const r = data.currentRecipe || data.recipe;\n                    if (r) {\n                        const upper = String(r).toUpperCase();\n                        if ([\n                            \"FULL_STACK\",\n                            \"CHACHA_HEAVY\",\n                            \"SALSA_LIGHT\",\n                            \"CHAOS_ONLY\",\n                            \"STREAM_FOCUS\"\n                        ].includes(upper)) {\n                            setActiveRecipe(upper);\n                            setPendingRecipe(null);\n                        }\n                    }\n                    addEventLog({\n                        type: \"success\",\n                        message: \"ZTM activation acknowledged (recipe=\".concat(data.currentRecipe || data.recipe || \"unknown\", \")\"),\n                        source: \"server\"\n                    });\n                } else {\n                    setPendingRecipe(null);\n                    addEventLog({\n                        type: \"error\",\n                        message: \"ZTM activation rejected: \".concat(data.error || \"unknown error\"),\n                        source: \"server\"\n                    });\n                }\n                break;\n            case \"adaptive_switch_acknowledged\":\n                // This is a broadcast; treat as informational (ESP32 will emit recipe_switched on commit)\n                addEventLog({\n                    type: data.success === false ? \"warning\" : \"info\",\n                    message: \"Switch ack broadcast: mode=\".concat(data.mode || \"ztm\", \" recipe=\").concat(data.recipe || \"unknown\", \" success=\").concat(data.success !== false),\n                    source: \"server\"\n                });\n                break;\n            case \"heuristics_update\":\n                updateHeuristics(data.metrics);\n                break;\n            case \"threat_alert\":\n                addAlert({\n                    type: data.severity || \"warning\",\n                    attackType: data.attackType,\n                    message: data.message,\n                    metric: data.metric,\n                    value: data.value,\n                    threshold: data.threshold,\n                    recipe: data.recipeSwitched\n                });\n                // Auto-switch recipe in ZTM mode\n                if (isZeroTrustMode && data.recipeSwitched) {\n                    setActiveRecipe(data.recipeSwitched);\n                    setLastSwitchReason(data.reason || \"Automatic threat response\");\n                    setLastSwitchTime(Date.now());\n                }\n                break;\n            case \"ztm_status\":\n            case \"ztm_status_update\":\n            case \"active_recipe_updated\":\n                {\n                    // ESP32 periodic/current status (source of truth)\n                    // Treat any of these messages as authoritative control-plane status\n                    const enabled = data.active !== undefined ? !!data.active : !!data.ztmEnabled;\n                    const r = data.currentRecipe || data.recipe;\n                    if (enabled) {\n                        setIsZeroTrustMode(true);\n                        if (r) {\n                            const upper = String(r).toUpperCase();\n                            if ([\n                                \"FULL_STACK\",\n                                \"CHACHA_HEAVY\",\n                                \"SALSA_LIGHT\",\n                                \"CHAOS_ONLY\",\n                                \"STREAM_FOCUS\"\n                            ].includes(upper)) {\n                                // If recipe actually changed, log it as a committed switch\n                                setActiveRecipe((prev)=>{\n                                    if (prev !== upper) {\n                                        addEventLog({\n                                            type: \"recipe_switch\",\n                                            message: \"Recipe committed: \".concat(prev, \" → \").concat(upper),\n                                            source: \"server\",\n                                            details: {\n                                                epoch: data.epoch,\n                                                reason: data.lastSwitchReason\n                                            }\n                                        });\n                                        setLastSwitchReason(data.lastSwitchReason || \"Switched to \".concat(upper));\n                                        setLastSwitchTime(Date.now());\n                                    }\n                                    return upper;\n                                });\n                                setPendingRecipe(null);\n                            }\n                        }\n                    } else {\n                        // If ESP32 says disabled, reflect that (even if UI thought active)\n                        setIsZeroTrustMode(false);\n                        setPendingRecipe(null);\n                    }\n                    break;\n                }\n            case \"recipe_switched\":\n                {\n                    // ESP32 commit event (authoritative)\n                    const newR = data.newRecipe || data.recipe || data.currentRecipe;\n                    const oldR = data.oldRecipe;\n                    const reason = data.reason;\n                    if (newR) {\n                        const upper = String(newR).toUpperCase();\n                        if ([\n                            \"FULL_STACK\",\n                            \"CHACHA_HEAVY\",\n                            \"SALSA_LIGHT\",\n                            \"CHAOS_ONLY\",\n                            \"STREAM_FOCUS\"\n                        ].includes(upper)) {\n                            setActiveRecipe(upper);\n                            setPendingRecipe(null);\n                            setLastSwitchReason(reason || \"Switched to \".concat(upper));\n                            setLastSwitchTime(Date.now());\n                            addEventLog({\n                                type: \"recipe_switch\",\n                                message: \"Recipe committed: \".concat(oldR ? \"\".concat(oldR, \" → \") : \"\").concat(upper).concat(reason ? \" (\".concat(reason, \")\") : \"\"),\n                                source: \"esp32\"\n                            });\n                        }\n                    }\n                    break;\n                }\n            case \"security_update\":\n                if (data.decrypt_failures !== undefined || data.hmac_failures !== undefined) {\n                    updateHeuristics({\n                        decryptFailures: data.decrypt_failures || 0,\n                        hmacFailures: data.hmac_failures || 0,\n                        replayAttempts: data.replay_attempts || 0\n                    });\n                }\n                break;\n            case \"decryption_update\":\n                var _data_decryptionTime, _data_finalPlaintext;\n                // Extract live latency from actual decryption time\n                if (data.decryptionTime !== undefined) {\n                    updateHeuristics({\n                        latencyMs: data.decryptionTime\n                    });\n                }\n                // Log the decryption event\n                addEventLog({\n                    type: \"health\",\n                    message: \"Data decrypted in \".concat((_data_decryptionTime = data.decryptionTime) === null || _data_decryptionTime === void 0 ? void 0 : _data_decryptionTime.toFixed(2), \"ms\"),\n                    source: \"server\",\n                    details: {\n                        plaintextLength: (_data_finalPlaintext = data.finalPlaintext) === null || _data_finalPlaintext === void 0 ? void 0 : _data_finalPlaintext.length\n                    }\n                });\n                break;\n            case \"health_data_update\":\n                // Log health data from ESP32\n                addEventLog({\n                    type: \"health\",\n                    message: \"Health: HR=\".concat(data.heartRate, \" SPO2=\").concat(data.spo2, \" Steps=\").concat(data.steps),\n                    source: \"esp32\"\n                });\n                break;\n        }\n    }, [\n        lastMessage,\n        isZeroTrustMode,\n        updateHeuristics,\n        addAlert,\n        addEventLog\n    ]);\n    const value = {\n        isZeroTrustMode,\n        isPasskeyVerified,\n        verifyPasskey,\n        enableZeroTrust,\n        disableZeroTrust,\n        activeRecipe,\n        switchRecipe,\n        lastSwitchReason,\n        lastSwitchTime,\n        heuristics,\n        updateHeuristics,\n        alerts,\n        addAlert,\n        dismissAlert,\n        clearAlerts,\n        eventLogs,\n        addEventLog,\n        clearEventLogs,\n        zeroTrustData\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(ZeroTrustContext.Provider, {\n        value: value,\n        children: children\n    }, void 0, false, {\n        fileName: \"D:\\\\Projects\\\\XHI2\\\\XenoCipher_Healthcare_IoT\\\\xenocipher-frontend\\\\context\\\\ZeroTrustContext.tsx\",\n        lineNumber: 533,\n        columnNumber: 5\n    }, this);\n}\n_s(ZeroTrustProvider, \"GpxaFH2zxbSSM+U5KAlJCJkJ8SM=\", false, function() {\n    return [\n        _WebSocketContext__WEBPACK_IMPORTED_MODULE_2__.useWebSocket\n    ];\n});\n_c = ZeroTrustProvider;\n// Hook to use Zero Trust context\nfunction useZeroTrust() {\n    _s1();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(ZeroTrustContext);\n    if (context === undefined) {\n        throw new Error(\"useZeroTrust must be used within a ZeroTrustProvider\");\n    }\n    return context;\n}\n_s1(useZeroTrust, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\n// Hook for security monitoring components\nfunction useZeroTrustSecurity() {\n    _s2();\n    const { isZeroTrustMode, zeroTrustData, heuristics, alerts } = useZeroTrust();\n    const getSecurityStatus = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        return {\n            isActive: isZeroTrustMode,\n            threatLevel: zeroTrustData.threatLevel,\n            activeAlerts: alerts.length,\n            heuristics\n        };\n    }, [\n        isZeroTrustMode,\n        zeroTrustData.threatLevel,\n        alerts.length,\n        heuristics\n    ]);\n    return {\n        securityStatus: getSecurityStatus(),\n        isZeroTrustMode,\n        zeroTrustData,\n        heuristics,\n        alerts\n    };\n}\n_s2(useZeroTrustSecurity, \"6z0EI+ALph9kvylCE9Hiv3OSI78=\", false, function() {\n    return [\n        useZeroTrust\n    ];\n});\n/* harmony default export */ __webpack_exports__[\"default\"] = (ZeroTrustContext);\nvar _c;\n$RefreshReg$(_c, \"ZeroTrustProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbnRleHQvWmVyb1RydXN0Q29udGV4dC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUEsK0JBQStCOzs7QUFHOEU7QUFDNUQ7QUFDeUU7QUErQzFILE1BQU1VLGlDQUFtQlQsb0RBQWFBLENBQW1DVTtBQU16RSx1REFBdUQ7QUFDdkQsTUFBTUMscUJBQXVDO0lBQzNDQyxXQUFXO0lBQ1hDLGNBQWM7SUFDZEMsZUFBZTtJQUNmQyxZQUFZO0lBQ1pDLGNBQWM7SUFDZEMsaUJBQWlCO0lBQ2pCQyxnQkFBZ0I7SUFDaEJDLGtCQUFrQjtJQUNsQkMsaUJBQWlCO0FBQ25CO0FBRU8sU0FBU0Msa0JBQWtCLEtBQW9DO1FBQXBDLEVBQUVDLFFBQVEsRUFBMEIsR0FBcEM7O0lBQ2hDLE1BQU0sRUFBRUMsV0FBVyxFQUFFQyxXQUFXLEVBQUUsR0FBR2xCLCtEQUFZQTtJQUVqRCxhQUFhO0lBQ2IsTUFBTSxDQUFDbUIsaUJBQWlCQyxtQkFBbUIsR0FBR3hCLCtDQUFRQSxDQUFDO0lBQ3ZELE1BQU0sQ0FBQ3lCLG1CQUFtQkMscUJBQXFCLEdBQUcxQiwrQ0FBUUEsQ0FBQztJQUUzRCxlQUFlO0lBQ2YsdUZBQXVGO0lBQ3ZGLE1BQU0sQ0FBQzJCLGNBQWNDLGdCQUFnQixHQUFHNUIsK0NBQVFBLENBQWU7SUFDL0QsTUFBTSxDQUFDNkIsZUFBZUMsaUJBQWlCLEdBQUc5QiwrQ0FBUUEsQ0FBc0I7SUFDeEUsTUFBTSxDQUFDK0Isa0JBQWtCQyxvQkFBb0IsR0FBR2hDLCtDQUFRQSxDQUFnQjtJQUN4RSxNQUFNLENBQUNpQyxnQkFBZ0JDLGtCQUFrQixHQUFHbEMsK0NBQVFBLENBQWdCO0lBRXBFLG1CQUFtQjtJQUNuQixNQUFNLENBQUNtQyxZQUFZQyxjQUFjLEdBQUdwQywrQ0FBUUEsQ0FBbUJTO0lBRS9ELGVBQWU7SUFDZixNQUFNLENBQUM0QixRQUFRQyxVQUFVLEdBQUd0QywrQ0FBUUEsQ0FBZ0IsRUFBRTtJQUV0RCxtQkFB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QVU1SDtZQUNWb0IsYUFBYUYsY0FBY0UsV0FBVztZQUN0Q3lHLGNBQWMvRyxPQUFPdUIsTUFBTTtZQUMzQnpCO1FBQ0Y7SUFDRixHQUFHO1FBQUNaO1FBQWlCa0IsY0FBY0UsV0FBVztRQUFFTixPQUFPdUIsTUFBTTtRQUFFekI7S0FBVztJQUUxRSxPQUFPO1FBQ0xrSCxnQkFBZ0JIO1FBQ2hCM0g7UUFDQWtCO1FBQ0FOO1FBQ0FFO0lBQ0Y7QUFDRjtJQW5CZ0I0Rzs7UUFDaURIOzs7QUFvQmpFLCtEQUFldkksZ0JBQWdCQSxFQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2NvbnRleHQvWmVyb1RydXN0Q29udGV4dC50c3g/NjlmNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBjb250ZXh0L1plcm9UcnVzdENvbnRleHQudHN4XG4ndXNlIGNsaWVudCdcblxuaW1wb3J0IFJlYWN0LCB7IGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQsIHVzZVN0YXRlLCB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VSZWYsIFJlYWN0Tm9kZSB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgdXNlV2ViU29ja2V0IH0gZnJvbSAnLi9XZWJTb2NrZXRDb250ZXh0J1xuaW1wb3J0IHsgY2hlY2tUaHJlc2hvbGRzLCBjYW5UcmlnZ2VyQWxlcnQsIHR5cGUgSGV1cmlzdGljTWV0cmljcyBhcyBUaHJlc2hvbGRNZXRyaWNzIH0gZnJvbSAnLi4vbGliL2hldXJpc3RpY3MtdGhyZXNob2xkcydcbmltcG9ydCB0eXBlIHsgWlRNUmVjaXBlS2V5IH0gZnJvbSAnLi4vY29tcG9uZW50cy96dG0vWlRNUmVjaXBlc1BhbmVsJ1xuaW1wb3J0IHR5cGUgeyBIZXVyaXN0aWNNZXRyaWNzIH0gZnJvbSAnLi4vY29tcG9uZW50cy96dG0vWlRNVGhyZWF0TWV0cmljc0Rhc2hib2FyZCdcbmltcG9ydCB0eXBlIHsgVGhyZWF0QWxlcnQgfSBmcm9tICcuLi9jb21wb25lbnRzL3p0bS9aVE1BbGVydFN5c3RlbSdcbmltcG9ydCB0eXBlIHsgTG9nRW50cnkgfSBmcm9tICcuLi9jb21wb25lbnRzL3p0bS9aVE1FdmVudExvZydcblxuZXhwb3J0IHR5cGUgVGhyZWF0TGV2ZWwgPSAnZ3JlZW4nIHwgJ3llbGxvdycgfCAncmVkJ1xuXG5pbnRlcmZhY2UgWmVyb1RydXN0Q29udGV4dFR5cGUge1xuICAvLyBDb3JlIHN0YXRlXG4gIGlzWmVyb1RydXN0TW9kZTogYm9vbGVhblxuICBpc1Bhc3NrZXlWZXJpZmllZDogYm9vbGVhblxuXG4gIC8vIEFjdGlvbnNcbiAgdmVyaWZ5UGFzc2tleTogKHBhc3NrZXk6IHN0cmluZykgPT4gUHJvbWlzZTxib29sZWFuPlxuICBlbmFibGVaZXJvVHJ1c3Q6IChwYXNza2V5Pzogc3RyaW5nKSA9PiB2b2lkXG4gIGRpc2FibGVaZXJvVHJ1c3Q6ICgpID0+IHZvaWRcblxuICAvLyBSZWNpcGUgbWFuYWdlbWVudFxuICBhY3RpdmVSZWNpcGU6IFpUTVJlY2lwZUtleVxuICBzd2l0Y2hSZWNpcGU6IChyZWNpcGU6IFpUTVJlY2lwZUtleSwgcmVhc29uPzogc3RyaW5nKSA9PiB2b2lkXG4gIGxhc3RTd2l0Y2hSZWFzb246IHN0cmluZyB8IG51bGxcbiAgbGFzdFN3aXRjaFRpbWU6IG51bWJlciB8IG51bGxcblxuICAvLyBIZXVyaXN0aWNzICYgTWV0cmljc1xuICBoZXVyaXN0aWNzOiBIZXVyaXN0aWNNZXRyaWNzXG4gIHVwZGF0ZUhldXJpc3RpY3M6IChtZXRyaWNzOiBQYXJ0aWFsPEhldXJpc3RpY01ldHJpY3M+KSA9PiB2b2lkXG5cbiAgLy8gQWxlcnRzXG4gIGFsZXJ0czogVGhyZWF0QWxlcnRbXVxuICBhZGRBbGVydDogKGFsZXJ0OiBPbWl0PFRocmVhdEFsZXJ0LCAnaWQnIHwgJ3RpbWVzdGFtcCc+KSA9PiB2b2lkXG4gIGRpc21pc3NBbGVydDogKGlkOiBzdHJpbmcpID0+IHZvaWRcbiAgY2xlYXJBbGVydHM6ICgpID0+IHZvaWRcblxuICAvLyBFdmVudCBMb2dcbiAgZXZlbnRMb2dzOiBMb2dFbnRyeVtdXG4gIGFkZEV2ZW50TG9nOiAoZW50cnk6IE9taXQ8TG9nRW50cnksICdpZCcgfCAndGltZXN0YW1wJz4pID0+IHZvaWRcbiAgY2xlYXJFdmVudExvZ3M6ICgpID0+IHZvaWRcblxuICAvLyBMZWdhY3kgZGF0YSBvYmplY3RcbiAgemVyb1RydXN0RGF0YToge1xuICAgIHNlc3Npb25LZXk/OiBzdHJpbmdcbiAgICBlcGhlbWVyYWxJZGVudGl0eT86IHN0cmluZ1xuICAgIHRocmVhdExldmVsOiBUaHJlYXRMZXZlbFxuICB9XG59XG5cbmNvbnN0IFplcm9UcnVzdENvbnRleHQgPSBjcmVhdGVDb250ZXh0PFplcm9UcnVzdENvbnRleHRUeXBlIHwgdW5kZWZpbmVkPih1bmRlZmluZWQpXG5cbmludGVyZmFjZSBaZXJvVHJ1c3RQcm92aWRlclByb3BzIHtcbiAgY2hpbGRyZW46IFJlYWN0Tm9kZVxufVxuXG4vLyBEZWZhdWx0IGhldXJpc3RpY3MgbWF0Y2hpbmcgaGV1cmlzdGljcy5qc29uIGJhc2VsaW5lXG5jb25zdCBERUZBVUxUX0hFVVJJU1RJQ1M6IEhldXJpc3RpY01ldHJpY3MgPSB7XG4gIGxhdGVuY3lNczogNDguNSxcbiAgZW50cm9weUFmdGVyOiA3LjgsXG4gIG1lbW9yeVBlcmNlbnQ6IDAuMjA0LFxuICBjcHVQZXJjZW50OiAwLjAsXG4gIGhtYWNGYWlsdXJlczogMCxcbiAgZGVjcnlwdEZhaWx1cmVzOiAwLFxuICByZXBsYXlBdHRlbXB0czogMCxcbiAgbWFsZm9ybWVkUGFja2V0czogMCxcbiAgdGltaW5nQW5vbWFsaWVzOiAwXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBaZXJvVHJ1c3RQcm92aWRlcih7IGNoaWxkcmVuIH06IFplcm9UcnVzdFByb3ZpZGVyUHJvcHMpIHtcbiAgY29uc3QgeyBsYXN0TWVzc2FnZSwgc2VuZE1lc3NhZ2UgfSA9IHVzZVdlYlNvY2tldCgpXG5cbiAgLy8gQ29yZSBzdGF0ZVxuICBjb25zdCBbaXNaZXJvVHJ1c3RNb2RlLCBzZXRJc1plcm9UcnVzdE1vZGVdID0gdXNlU3RhdGUoZmFsc2UpXG4gIGNvbnN0IFtpc1Bhc3NrZXlWZXJpZmllZCwgc2V0SXNQYXNza2V5VmVyaWZpZWRdID0gdXNlU3RhdGUoZmFsc2UpXG5cbiAgLy8gUmVjaXBlIHN0YXRlXG4gIC8vIE5vdGU6IHRoaXMgaXMgVUkgc3RhdGU7IHRoZSBFU1AzMiBpcyB0aGUgc291cmNlIG9mIHRydXRoLiBXZSByZWNvbmNpbGUgb24gV1MgZXZlbnRzLlxuICBjb25zdCBbYWN0aXZlUmVjaXBlLCBzZXRBY3RpdmVSZWNpcGVdID0gdXNlU3RhdGU8WlRNUmVjaXBlS2V5PignQ0hBT1NfT05MWScpXG4gIGNvbnN0IFtwZW5kaW5nUmVjaXBlLCBzZXRQZW5kaW5nUmVjaXBlXSA9IHVzZVN0YXRlPFpUTVJlY2lwZUtleSB8IG51bGw+KG51bGwpXG4gIGNvbnN0IFtsYXN0U3dpdGNoUmVhc29uLCBzZXRMYXN0U3dpdGNoUmVhc29uXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpXG4gIGNvbnN0IFtsYXN0U3dpdGNoVGltZSwgc2V0TGFzdFN3aXRjaFRpbWVdID0gdXNlU3RhdGU8bnVtYmVyIHwgbnVsbD4obnVsbClcblxuICAvLyBIZXVyaXN0aWNzIHN0YXRlXG4gIGNvbnN0IFtoZXVyaXN0aWNzLCBzZXRIZXVyaXN0aWNzXSA9IHVzZVN0YXRlPEhldXJpc3RpY01ldHJpY3M+KERFRkFVTFRfSEVVUklTVElDUylcblxuICAvLyBBbGVydHMgc3RhdGVcbiAgY29uc3QgW2FsZXJ0cywgc2V0QWxlcnRzXSA9IHVzZVN0YXRlPFRocmVhdEFsZXJ0W10+KFtdKVxuXG4gIC8vIEV2ZW50IGxvZ3Mgc3RhdGVcbiAgY29uc3QgW2V2ZW50TG9ncywgc2V0RXZlbnRMb2dzXSA9IHVzZVN0YXRlPExvZ0VudHJ5W10+KFtdKVxuXG4gIC8vIExlZ2FjeSBkYXRhXG4gIGNvbnN0IFt6ZXJvVHJ1c3REYXRhLCBzZXRaZXJvVHJ1c3REYXRhXSA9IHVzZVN0YXRlPHtcbiAgICBzZXNzaW9uS2V5Pzogc3RyaW5nXG4gICAgZXBoZW1lcmFsSWRlbnRpdHk/OiBzdHJpbmdcbiAgICB0aHJlYXRMZXZlbDogVGhyZWF0TGV2ZWxcbiAgfT4oeyB0aHJlYXRMZXZlbDogJ2dyZWVuJyB9KVxuXG4gIC8vIFBhc3NrZXkgdmVyaWZpY2F0aW9uXG4gIGNvbnN0IHZlcmlmeVBhc3NrZXkgPSB1c2VDYWxsYmFjayhhc3luYyAocGFzc2tleTogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiA9PiB7XG4gICAgY29uc3QgY29ycmVjdFBhc3NrZXkgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19aVE1fUEFTU0tFWSB8fCAnMTIzNCdcblxuICAgIGlmIChwYXNza2V5ID09PSBjb3JyZWN0UGFzc2tleSkge1xuICAgICAgc2V0SXNQYXNza2V5VmVyaWZpZWQodHJ1ZSlcbiAgICAgIGFkZEV2ZW50TG9nKHtcbiAgICAgICAgdHlwZTogJ3N1Y2Nlc3MnLFxuICAgICAgICBtZXNzYWdlOiAnWlRNIHBhc3NrZXkgdmVyaWZpZWQgc3VjY2Vzc2Z1bGx5JyxcbiAgICAgICAgc291cmNlOiAnenRtJ1xuICAgICAgfSlcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgYWRkRXZlbnRMb2coe1xuICAgICAgdHlwZTogJ3dhcm5pbmcnLFxuICAgICAgbWVzc2FnZTogJ0ludmFsaWQgWlRNIHBhc3NrZXkgYXR0ZW1wdCcsXG4gICAgICBzb3VyY2U6ICd6dG0nXG4gICAgfSlcbiAgICByZXR1cm4gZmFsc2VcbiAgfSwgW10pXG5cbiAgLy8gRW5hYmxlIFpUTVxuICBjb25zdCBlbmFibGVaZXJvVHJ1c3QgPSB1c2VDYWxsYmFjaygocGFzc2tleT86IHN0cmluZykgPT4ge1xuICAgIGNvbnNvbGUubG9nKCdbWmVybyBUcnVzdF0g8J+agCBBY3RpdmF0aW5nIFplcm8gVHJ1c3QgTW9kZS4uLicpXG5cbiAgICAvLyBHZW5lcmF0ZSBlcGhlbWVyYWwgc2Vzc2lvbiBkYXRhXG4gICAgY29uc3Qgc2Vzc2lvbktleSA9IEFycmF5LmZyb20oeyBsZW5ndGg6IDMyIH0sICgpID0+XG4gICAgICBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyNTYpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpXG4gICAgKS5qb2luKCcnKVxuXG4gICAgY29uc3Qgd29yZHMgPSBbXG4gICAgICAncXVhbnR1bScsICdsYXR0aWNlJywgJ2NpcGhlcicsICd2b2lkJywgJ25lb24nLCAndHJ1c3QnLCAnemVybycsICdidXJuJyxcbiAgICAgICdjcnlwdG8nLCAnc2VjdXJlJywgJ2dob3N0JywgJ3NoYWRvdycsICdibGFjaycsICdyZWQnLCAnZ3JlZW4nLCAncHVsc2UnXG4gICAgXVxuXG4gICAgY29uc3QgZXBoZW1lcmFsSWRlbnRpdHkgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiA0IH0sICgpID0+XG4gICAgICB3b3Jkc1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiB3b3Jkcy5sZW5ndGgpXVxuICAgICkuam9pbignLScpXG5cbiAgICBzZXRaZXJvVHJ1c3REYXRhKHtcbiAgICAgIHNlc3Npb25LZXksXG4gICAgICBlcGhlbWVyYWxJZGVudGl0eSxcbiAgICAgIHRocmVhdExldmVsOiAneWVsbG93J1xuICAgIH0pXG4gICAgc2V0SXNaZXJvVHJ1c3RNb2RlKHRydWUpXG4gICAgLy8gUmVxdWVzdCBiYXNlbGluZSByZWNpcGU7IEVTUDMyIHdpbGwgY29uZmlybSB2aWEgenRtX2FjdGl2YXRpb25fYWNrbm93bGVkZ2VkL3p0bV9zdGF0dXNcbiAgICBzZXRQZW5kaW5nUmVjaXBlKCdDSEFPU19PTkxZJylcbiAgICBzZXRMYXN0U3dpdGNoUmVhc29uKCdaVE0gYWN0aXZhdGlvbiAtIHN0YXJ0aW5nIHdpdGggYmFzZWxpbmUgcmVjaXBlJylcbiAgICBzZXRMYXN0U3dpdGNoVGltZShEYXRlLm5vdygpKVxuXG4gICAgLy8gU2VuZCBhY3RpdmF0aW9uIHRvIGJhY2tlbmRcbiAgICAvLyBJbmNsdWRlIHBhc3NrZXkgZm9yIHNlcnZlci1zaWRlIHZlcmlmaWNhdGlvbiAoZGVmYXVsdCB0byAnMTIzNCcgaWYgbm90IHByb3ZpZGVkKVxuICAgIGNvbnN0IGZpbmFsUGFzc2tleSA9IHBhc3NrZXkgfHwgcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfWlRNX1BBU1NLRVkgfHwgJzEyMzQnXG4gICAgc2VuZE1lc3NhZ2Uoe1xuICAgICAgdHlwZTogJ3p0bV9hY3RpdmF0ZV9yZXF1ZXN0JyxcbiAgICAgIHBhc3NrZXk6IGZpbmFsUGFzc2tleSxcbiAgICAgIHNlc3Npb25LZXksXG4gICAgICBlcGhlbWVyYWxJZGVudGl0eSxcbiAgICAgIGluaXRpYWxSZWNpcGU6ICdDSEFPU19PTkxZJ1xuICAgIH0pXG5cbiAgICBhZGRFdmVudExvZyh7XG4gICAgICB0eXBlOiAncmVjaXBlX3N3aXRjaCcsXG4gICAgICBtZXNzYWdlOiAnWmVybyBUcnVzdCBNb2RlIGFjdGl2YXRlZCB3aXRoIENIQU9TX09OTFkgYmFzZWxpbmUnLFxuICAgICAgc291cmNlOiAnenRtJyxcbiAgICAgIGRldGFpbHM6IHsgZXBoZW1lcmFsSWRlbnRpdHkgfVxuICAgIH0pXG5cbiAgICBjb25zb2xlLmxvZygnW1plcm8gVHJ1c3RdIOKchSBNb2RlIGFjdGl2YXRlZCB3aXRoIGVwaGVtZXJhbCBpZGVudGl0eTonLCBlcGhlbWVyYWxJZGVudGl0eSlcbiAgfSwgW3NlbmRNZXNzYWdlXSlcblxuICAvLyBEaXNhYmxlIFpUTVxuICBjb25zdCBkaXNhYmxlWmVyb1RydXN0ID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGNvbnNvbGUubG9nKCdbWmVybyBUcnVzdF0g8J+Xke+4jyBEZWFjdGl2YXRpbmcgWmVybyBUcnVzdCBNb2RlLi4uJylcblxuICAgIHNlbmRNZXNzYWdlKHtcbiAgICAgIHR5cGU6ICd6dG1fZGVhY3RpdmF0ZV9yZXF1ZXN0J1xuICAgIH0pXG5cbiAgICBhZGRFdmVudExvZyh7XG4gICAgICB0eXBlOiAnaW5mbycsXG4gICAgICBtZXNzYWdlOiAnWmVybyBUcnVzdCBNb2RlIGRlYWN0aXZhdGVkIC0gcmV0dXJuaW5nIHRvIE5vcm1hbCBNb2RlJyxcbiAgICAgIHNvdXJjZTogJ3p0bSdcbiAgICB9KVxuXG4gICAgc2V0WmVyb1RydXN0RGF0YSh7IHRocmVhdExldmVsOiAnZ3JlZW4nIH0pXG4gICAgc2V0SXNaZXJvVHJ1c3RNb2RlKGZhbHNlKVxuICAgIHNldElzUGFzc2tleVZlcmlmaWVkKGZhbHNlKVxuICAgIHNldEFjdGl2ZVJlY2lwZSgnQ0hBT1NfT05MWScpXG4gICAgc2V0UGVuZGluZ1JlY2lwZShudWxsKVxuICAgIHNldExhc3RTd2l0Y2hSZWFzb24obnVsbClcbiAgICBzZXRMYXN0U3dpdGNoVGltZShudWxsKVxuICAgIHNldEhldXJpc3RpY3MoREVGQVVMVF9IRVVSSVNUSUNTKVxuXG4gICAgY29uc29sZS5sb2coJ1taZXJvIFRydXN0XSDinIUgTW9kZSBkZWFjdGl2YXRlZCwgYWxsIGRhdGEgZGVzdHJveWVkJylcbiAgfSwgW3NlbmRNZXNzYWdlXSlcblxuICAvLyBTd2l0Y2ggcmVjaXBlXG4gIGNvbnN0IHN3aXRjaFJlY2lwZSA9IHVzZUNhbGxiYWNrKChyZWNpcGU6IFpUTVJlY2lwZUtleSwgcmVhc29uPzogc3RyaW5nKSA9PiB7XG4gICAgLy8gQ29vbGRvd24gY2hlY2sgKDUgc2Vjb25kcyBtaW5pbXVtKVxuICAgIGlmIChsYXN0U3dpdGNoVGltZSAmJiBEYXRlLm5vdygpIC0gbGFzdFN3aXRjaFRpbWUgPCA1MDAwKSB7XG4gICAgICBhZGRFdmVudExvZyh7XG4gICAgICAgIHR5cGU6ICd3YXJuaW5nJyxcbiAgICAgICAgbWVzc2FnZTogJ1JlY2lwZSBzd2l0Y2ggYmxvY2tlZCAtIGNvb2xkb3duIGFjdGl2ZSAoNXMgbWluaW11bSknLFxuICAgICAgICBzb3VyY2U6ICd6dG0nXG4gICAgICB9KVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3Qgc3dpdGNoUmVhc29uID0gcmVhc29uIHx8IGBNYW51YWwgc3dpdGNoIHRvICR7cmVjaXBlfWBcbiAgICAvLyBEbyBub3QgaW1tZWRpYXRlbHkgY2xhaW0gdGhlIHJlY2lwZSBpcyBhY3RpdmU7IHdhaXQgZm9yIEVTUDMyIGNvbmZpcm1hdGlvblxuICAgIHNldFBlbmRpbmdSZWNpcGUocmVjaXBlKVxuICAgIHNldExhc3RTd2l0Y2hSZWFzb24oc3dpdGNoUmVhc29uKVxuICAgIHNldExhc3RTd2l0Y2hUaW1lKERhdGUubm93KCkpXG5cbiAgICBzZW5kTWVzc2FnZSh7XG4gICAgICB0eXBlOiAnYWRhcHRpdmVfc3dpdGNoX3JlcXVlc3QnLFxuICAgICAgbW9kZTogJ3p0bScsXG4gICAgICByZWNpcGU6IHJlY2lwZS50b1VwcGVyQ2FzZSgpICAvLyBTZXJ2ZXIgZXhwZWN0cyB1cHBlcmNhc2U6IENIQU9TX09OTFksIFNBTFNBX0xJR0hULCBldGMuXG4gICAgfSlcblxuICAgIGFkZEV2ZW50TG9nKHtcbiAgICAgIHR5cGU6ICdyZWNpcGVfc3dpdGNoJyxcbiAgICAgIG1lc3NhZ2U6IGBTd2l0Y2ggcmVxdWVzdGVkIOKGkiAke3JlY2lwZX06ICR7c3dpdGNoUmVhc29ufWAsXG4gICAgICBzb3VyY2U6ICd6dG0nLFxuICAgICAgZGV0YWlsczogeyByZWNpcGUsIHJlYXNvbjogc3dpdGNoUmVhc29uLCBwZW5kaW5nOiB0cnVlIH1cbiAgICB9KVxuXG4gICAgY29uc29sZS5sb2coYFtaZXJvIFRydXN0XSDimqEgUmVjaXBlIHN3aXRjaGVkIHRvICR7cmVjaXBlfTogJHtzd2l0Y2hSZWFzb259YClcbiAgfSwgW2xhc3RTd2l0Y2hUaW1lLCBzZW5kTWVzc2FnZV0pXG5cbiAgLy8gVXBkYXRlIGhldXJpc3RpY3NcbiAgY29uc3QgdXBkYXRlSGV1cmlzdGljcyA9IHVzZUNhbGxiYWNrKChtZXRyaWNzOiBQYXJ0aWFsPEhldXJpc3RpY01ldHJpY3M+KSA9PiB7XG4gICAgc2V0SGV1cmlzdGljcyhwcmV2ID0+ICh7IC4uLnByZXYsIC4uLm1ldHJpY3MgfSkpXG4gIH0sIFtdKVxuXG4gIC8vIFRyYWNrIGxhc3QgdGhyZXNob2xkIGNoZWNrIHRvIGF2b2lkIGR1cGxpY2F0ZSBhbGVydHNcbiAgY29uc3QgbGFzdFRocmVzaG9sZENoZWNrID0gdXNlUmVmPG51bWJlcj4oMClcblxuICAvLyBDaGVjayB0aHJlc2hvbGRzIG9uIGhldXJpc3RpY3MgY2hhbmdlIC0gd29ya3MgaW4gQk9USCBOb3JtYWwgYW5kIFpUTSBtb2Rlc1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KClcbiAgICAvLyBPbmx5IGNoZWNrIGV2ZXJ5IDIgc2Vjb25kcyB0byBwcmV2ZW50IHNwYW1cbiAgICBpZiAobm93IC0gbGFzdFRocmVzaG9sZENoZWNrLmN1cnJlbnQgPCAyMDAwKSByZXR1cm5cbiAgICBsYXN0VGhyZXNob2xkQ2hlY2suY3VycmVudCA9IG5vd1xuXG4gICAgLy8gQ2hlY2sgdGhyZXNob2xkcyBhZ2FpbnN0IGN1cnJlbnQgaGV1cmlzdGljc1xuICAgIGNvbnN0IHRyaWdnZXJzID0gY2hlY2tUaHJlc2hvbGRzKGhldXJpc3RpY3MgYXMgVGhyZXNob2xkTWV0cmljcylcblxuICAgIGZvciAoY29uc3QgdHJpZ2dlciBvZiB0cmlnZ2Vycykge1xuICAgICAgLy8gQ2hlY2sgY29vbGRvd24gdG8gcHJldmVudCBkdXBsaWNhdGUgYWxlcnRzXG4gICAgICBpZiAoIWNhblRyaWdnZXJBbGVydCh0cmlnZ2VyLnByb2ZpbGUubmFtZSwgdHJpZ2dlci5wcm9maWxlLmNvb2xkb3duU2Vjb25kcykpIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gR2VuZXJhdGUgYWxlcnQgKHdvcmtzIGluIGJvdGggbW9kZXMpXG4gICAgICBjb25zdCBuZXdBbGVydDogVGhyZWF0QWxlcnQgPSB7XG4gICAgICAgIGlkOiBgYWxlcnQtJHtEYXRlLm5vdygpfS0ke01hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCA5KX1gLFxuICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICAgIHR5cGU6IHRyaWdnZXIucHJvZmlsZS5zZXZlcml0eSxcbiAgICAgICAgYXR0YWNrVHlwZTogdHJpZ2dlci5wcm9maWxlLmRpc3BsYXlOYW1lLFxuICAgICAgICBtZXNzYWdlOiB0cmlnZ2VyLnByb2ZpbGUucmVhc29uLFxuICAgICAgICBtZXRyaWM6IHRyaWdnZXIubWV0cmljLFxuICAgICAgICB2YWx1ZTogdHJpZ2dlci52YWx1ZSxcbiAgICAgICAgdGhyZXNob2xkOiB0cmlnZ2VyLnRocmVzaG9sZCxcbiAgICAgICAgcmVjaXBlOiBpc1plcm9UcnVzdE1vZGUgPyB0cmlnZ2VyLnByb2ZpbGUudGFyZ2V0UmVjaXBlIDogdW5kZWZpbmVkXG4gICAgICB9XG4gICAgICBzZXRBbGVydHMocHJldiA9PiBbbmV3QWxlcnQsIC4uLnByZXZdLnNsaWNlKDAsIDUwKSlcblxuICAgICAgLy8gTG9nIHRoZSBhbGVydFxuICAgICAgYWRkRXZlbnRMb2coe1xuICAgICAgICB0eXBlOiAndGhyZWF0JyxcbiAgICAgICAgbWVzc2FnZTogYCR7dHJpZ2dlci5wcm9maWxlLmRpc3BsYXlOYW1lfTogJHt0cmlnZ2VyLnByb2ZpbGUucmVhc29ufWAsXG4gICAgICAgIHNvdXJjZTogaXNaZXJvVHJ1c3RNb2RlID8gJ3p0bScgOiAnc3lzdGVtJyxcbiAgICAgICAgZGV0YWlsczoge1xuICAgICAgICAgIG1ldHJpYzogdHJpZ2dlci5tZXRyaWMsXG4gICAgICAgICAgdmFsdWU6IHRyaWdnZXIudmFsdWUsXG4gICAgICAgICAgdGhyZXNob2xkOiB0cmlnZ2VyLnRocmVzaG9sZCxcbiAgICAgICAgICBtb2RlOiBpc1plcm9UcnVzdE1vZGUgPyAnWlRNJyA6ICdOT1JNQUwnXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIC8vIE9ubHkgYXV0by1zd2l0Y2ggcmVjaXBlIGluIFpUTSBtb2RlXG4gICAgICBpZiAoaXNaZXJvVHJ1c3RNb2RlICYmIHRyaWdnZXIucHJvZmlsZS50YXJnZXRSZWNpcGUpIHtcbiAgICAgICAgc3dpdGNoUmVjaXBlKHRyaWdnZXIucHJvZmlsZS50YXJnZXRSZWNpcGUgYXMgWlRNUmVjaXBlS2V5LCB0cmlnZ2VyLnByb2ZpbGUucmVhc29uKVxuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmxvZyhgW0FsZXJ0XSAke2lzWmVyb1RydXN0TW9kZSA/ICfwn5S0IFpUTScgOiAn8J+foSBOb3JtYWwnfTogJHt0cmlnZ2VyLnByb2ZpbGUuZGlzcGxheU5hbWV9YCwge1xuICAgICAgICBtZXRyaWM6IHRyaWdnZXIubWV0cmljLFxuICAgICAgICB2YWx1ZTogdHJpZ2dlci52YWx1ZSxcbiAgICAgICAgdGhyZXNob2xkOiB0cmlnZ2VyLnRocmVzaG9sZCxcbiAgICAgICAgYXV0b1N3aXRjaDogaXNaZXJvVHJ1c3RNb2RlXG4gICAgICB9KVxuICAgIH1cbiAgfSwgW2hldXJpc3RpY3MsIGlzWmVyb1RydXN0TW9kZV0pXG5cbiAgLy8gQWRkIGFsZXJ0XG4gIGNvbnN0IGFkZEFsZXJ0ID0gdXNlQ2FsbGJhY2soKGFsZXJ0OiBPbWl0PFRocmVhdEFsZXJ0LCAnaWQnIHwgJ3RpbWVzdGFtcCc+KSA9PiB7XG4gICAgY29uc3QgbmV3QWxlcnQ6IFRocmVhdEFsZXJ0ID0ge1xuICAgICAgLi4uYWxlcnQsXG4gICAgICBpZDogYGFsZXJ0LSR7RGF0ZS5ub3coKX0tJHtNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwgOSl9YCxcbiAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKVxuICAgIH1cbiAgICBzZXRBbGVydHMocHJldiA9PiBbbmV3QWxlcnQsIC4uLnByZXZdLnNsaWNlKDAsIDUwKSkgLy8gS2VlcCBtYXggNTAgYWxlcnRzXG5cbiAgICAvLyBBbHNvIGxvZyB0byBldmVudCBsb2dcbiAgICBhZGRFdmVudExvZyh7XG4gICAgICB0eXBlOiAndGhyZWF0JyxcbiAgICAgIG1lc3NhZ2U6IGAke2FsZXJ0LmF0dGFja1R5cGV9OiAke2FsZXJ0Lm1lc3NhZ2V9YCxcbiAgICAgIHNvdXJjZTogJ3p0bScsXG4gICAgICBkZXRhaWxzOiB7XG4gICAgICAgIG1ldHJpYzogYWxlcnQubWV0cmljLFxuICAgICAgICB2YWx1ZTogYWxlcnQudmFsdWUsXG4gICAgICAgIHRocmVzaG9sZDogYWxlcnQudGhyZXNob2xkXG4gICAgICB9XG4gICAgfSlcbiAgfSwgW10pXG5cbiAgY29uc3QgZGlzbWlzc0FsZXJ0ID0gdXNlQ2FsbGJhY2soKGlkOiBzdHJpbmcpID0+IHtcbiAgICBzZXRBbGVydHMocHJldiA9PiBwcmV2LmZpbHRlcihhID0+IGEuaWQgIT09IGlkKSlcbiAgfSwgW10pXG5cbiAgY29uc3QgY2xlYXJBbGVydHMgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgc2V0QWxlcnRzKFtdKVxuICB9LCBbXSlcblxuICAvLyBBZGQgZXZlbnQgbG9nXG4gIGNvbnN0IGFkZEV2ZW50TG9nID0gdXNlQ2FsbGJhY2soKGVudHJ5OiBPbWl0PExvZ0VudHJ5LCAnaWQnIHwgJ3RpbWVzdGFtcCc+KSA9PiB7XG4gICAgY29uc3QgbmV3RW50cnk6IExvZ0VudHJ5ID0ge1xuICAgICAgLi4uZW50cnksXG4gICAgICBpZDogYGxvZy0ke0RhdGUubm93KCl9LSR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDkpfWAsXG4gICAgICB0aW1lc3RhbXA6IERhdGUubm93KClcbiAgICB9XG4gICAgc2V0RXZlbnRMb2dzKHByZXYgPT4gWy4uLnByZXYsIG5ld0VudHJ5XS5zbGljZSgtMTAwKSkgLy8gS2VlcCBsYXN0IDEwMCBsb2dzXG4gIH0sIFtdKVxuXG4gIGNvbnN0IGNsZWFyRXZlbnRMb2dzID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIHNldEV2ZW50TG9ncyhbXSlcbiAgfSwgW10pXG5cbiAgLy8gTGlzdGVuIGZvciBXZWJTb2NrZXQgbWVzc2FnZXNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWxhc3RNZXNzYWdlKSByZXR1cm5cblxuICAgIGNvbnN0IHsgdHlwZSwgLi4uZGF0YSB9ID0gbGFzdE1lc3NhZ2VcblxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnenRtX2FjdGl2YXRpb25fYWNrbm93bGVkZ2VkJzpcbiAgICAgICAgaWYgKGRhdGEuc3VjY2Vzcykge1xuICAgICAgICAgIHNldFplcm9UcnVzdERhdGEocHJldiA9PiAoeyAuLi5wcmV2LCB0aHJlYXRMZXZlbDogJ2dyZWVuJyB9KSlcbiAgICAgICAgICAvLyBQcmVmZXIgRVNQMzItcHJvdmlkZWQgcmVjaXBlIGZpZWxkcyAoY3VycmVudFJlY2lwZS9yZWNpcGUpXG4gICAgICAgICAgY29uc3QgciA9IChkYXRhLmN1cnJlbnRSZWNpcGUgfHwgZGF0YS5yZWNpcGUpIGFzIHN0cmluZyB8IHVuZGVmaW5lZFxuICAgICAgICAgIGlmIChyKSB7XG4gICAgICAgICAgICBjb25zdCB1cHBlciA9IFN0cmluZyhyKS50b1VwcGVyQ2FzZSgpXG4gICAgICAgICAgICBpZiAoWydGVUxMX1NUQUNLJywgJ0NIQUNIQV9IRUFWWScsICdTQUxTQV9MSUdIVCcsICdDSEFPU19PTkxZJywgJ1NUUkVBTV9GT0NVUyddLmluY2x1ZGVzKHVwcGVyKSkge1xuICAgICAgICAgICAgICBzZXRBY3RpdmVSZWNpcGUodXBwZXIgYXMgWlRNUmVjaXBlS2V5KVxuICAgICAgICAgICAgICBzZXRQZW5kaW5nUmVjaXBlKG51bGwpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGFkZEV2ZW50TG9nKHtcbiAgICAgICAgICAgIHR5cGU6ICdzdWNjZXNzJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGBaVE0gYWN0aXZhdGlvbiBhY2tub3dsZWRnZWQgKHJlY2lwZT0keyhkYXRhLmN1cnJlbnRSZWNpcGUgfHwgZGF0YS5yZWNpcGUgfHwgJ3Vua25vd24nKX0pYCxcbiAgICAgICAgICAgIHNvdXJjZTogJ3NlcnZlcidcbiAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNldFBlbmRpbmdSZWNpcGUobnVsbClcbiAgICAgICAgICBhZGRFdmVudExvZyh7XG4gICAgICAgICAgICB0eXBlOiAnZXJyb3InLFxuICAgICAgICAgICAgbWVzc2FnZTogYFpUTSBhY3RpdmF0aW9uIHJlamVjdGVkOiAke2RhdGEuZXJyb3IgfHwgJ3Vua25vd24gZXJyb3InfWAsXG4gICAgICAgICAgICBzb3VyY2U6ICdzZXJ2ZXInXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgICBicmVha1xuXG4gICAgICBjYXNlICdhZGFwdGl2ZV9zd2l0Y2hfYWNrbm93bGVkZ2VkJzpcbiAgICAgICAgLy8gVGhpcyBpcyBhIGJyb2FkY2FzdDsgdHJlYXQgYXMgaW5mb3JtYXRpb25hbCAoRVNQMzIgd2lsbCBlbWl0IHJlY2lwZV9zd2l0Y2hlZCBvbiBjb21taXQpXG4gICAgICAgIGFkZEV2ZW50TG9nKHtcbiAgICAgICAgICB0eXBlOiBkYXRhLnN1Y2Nlc3MgPT09IGZhbHNlID8gJ3dhcm5pbmcnIDogJ2luZm8nLFxuICAgICAgICAgIG1lc3NhZ2U6IGBTd2l0Y2ggYWNrIGJyb2FkY2FzdDogbW9kZT0ke2RhdGEubW9kZSB8fCAnenRtJ30gcmVjaXBlPSR7ZGF0YS5yZWNpcGUgfHwgJ3Vua25vd24nfSBzdWNjZXNzPSR7ZGF0YS5zdWNjZXNzICE9PSBmYWxzZX1gLFxuICAgICAgICAgIHNvdXJjZTogJ3NlcnZlcidcbiAgICAgICAgfSlcbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSAnaGV1cmlzdGljc191cGRhdGUnOlxuICAgICAgICB1cGRhdGVIZXVyaXN0aWNzKGRhdGEubWV0cmljcylcbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSAndGhyZWF0X2FsZXJ0JzpcbiAgICAgICAgYWRkQWxlcnQoe1xuICAgICAgICAgIHR5cGU6IGRhdGEuc2V2ZXJpdHkgfHwgJ3dhcm5pbmcnLFxuICAgICAgICAgIGF0dGFja1R5cGU6IGRhdGEuYXR0YWNrVHlwZSxcbiAgICAgICAgICBtZXNzYWdlOiBkYXRhLm1lc3NhZ2UsXG4gICAgICAgICAgbWV0cmljOiBkYXRhLm1ldHJpYyxcbiAgICAgICAgICB2YWx1ZTogZGF0YS52YWx1ZSxcbiAgICAgICAgICB0aHJlc2hvbGQ6IGRhdGEudGhyZXNob2xkLFxuICAgICAgICAgIHJlY2lwZTogZGF0YS5yZWNpcGVTd2l0Y2hlZFxuICAgICAgICB9KVxuXG4gICAgICAgIC8vIEF1dG8tc3dpdGNoIHJlY2lwZSBpbiBaVE0gbW9kZVxuICAgICAgICBpZiAoaXNaZXJvVHJ1c3RNb2RlICYmIGRhdGEucmVjaXBlU3dpdGNoZWQpIHtcbiAgICAgICAgICBzZXRBY3RpdmVSZWNpcGUoZGF0YS5yZWNpcGVTd2l0Y2hlZCBhcyBaVE1SZWNpcGVLZXkpXG4gICAgICAgICAgc2V0TGFzdFN3aXRjaFJlYXNvbihkYXRhLnJlYXNvbiB8fCAnQXV0b21hdGljIHRocmVhdCByZXNwb25zZScpXG4gICAgICAgICAgc2V0TGFzdFN3aXRjaFRpbWUoRGF0ZS5ub3coKSlcbiAgICAgICAgfVxuICAgICAgICBicmVha1xuXG4gICAgICBjYXNlICd6dG1fc3RhdHVzJzpcbiAgICAgIGNhc2UgJ3p0bV9zdGF0dXNfdXBkYXRlJzpcbiAgICAgIGNhc2UgJ2FjdGl2ZV9yZWNpcGVfdXBkYXRlZCc6IHtcbiAgICAgICAgLy8gRVNQMzIgcGVyaW9kaWMvY3VycmVudCBzdGF0dXMgKHNvdXJjZSBvZiB0cnV0aClcbiAgICAgICAgLy8gVHJlYXQgYW55IG9mIHRoZXNlIG1lc3NhZ2VzIGFzIGF1dGhvcml0YXRpdmUgY29udHJvbC1wbGFuZSBzdGF0dXNcbiAgICAgICAgY29uc3QgZW5hYmxlZCA9IGRhdGEuYWN0aXZlICE9PSB1bmRlZmluZWQgPyAhIWRhdGEuYWN0aXZlIDogISFkYXRhLnp0bUVuYWJsZWRcbiAgICAgICAgY29uc3QgciA9IChkYXRhLmN1cnJlbnRSZWNpcGUgfHwgZGF0YS5yZWNpcGUpIGFzIHN0cmluZyB8IHVuZGVmaW5lZFxuICAgICAgICBpZiAoZW5hYmxlZCkge1xuICAgICAgICAgIHNldElzWmVyb1RydXN0TW9kZSh0cnVlKVxuICAgICAgICAgIGlmIChyKSB7XG4gICAgICAgICAgICBjb25zdCB1cHBlciA9IFN0cmluZyhyKS50b1VwcGVyQ2FzZSgpXG4gICAgICAgICAgICBpZiAoWydGVUxMX1NUQUNLJywgJ0NIQUNIQV9IRUFWWScsICdTQUxTQV9MSUdIVCcsICdDSEFPU19PTkxZJywgJ1NUUkVBTV9GT0NVUyddLmluY2x1ZGVzKHVwcGVyKSkge1xuICAgICAgICAgICAgICAvLyBJZiByZWNpcGUgYWN0dWFsbHkgY2hhbmdlZCwgbG9nIGl0IGFzIGEgY29tbWl0dGVkIHN3aXRjaFxuICAgICAgICAgICAgICBzZXRBY3RpdmVSZWNpcGUocHJldiA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHByZXYgIT09IHVwcGVyKSB7XG4gICAgICAgICAgICAgICAgICBhZGRFdmVudExvZyh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdyZWNpcGVfc3dpdGNoJyxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYFJlY2lwZSBjb21taXR0ZWQ6ICR7cHJldn0g4oaSICR7dXBwZXJ9YCxcbiAgICAgICAgICAgICAgICAgICAgc291cmNlOiAnc2VydmVyJyxcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlsczoge1xuICAgICAgICAgICAgICAgICAgICAgIGVwb2NoOiBkYXRhLmVwb2NoLFxuICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbjogZGF0YS5sYXN0U3dpdGNoUmVhc29uXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICBzZXRMYXN0U3dpdGNoUmVhc29uKGRhdGEubGFzdFN3aXRjaFJlYXNvbiB8fCBgU3dpdGNoZWQgdG8gJHt1cHBlcn1gKVxuICAgICAgICAgICAgICAgICAgc2V0TGFzdFN3aXRjaFRpbWUoRGF0ZS5ub3coKSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVwcGVyIGFzIFpUTVJlY2lwZUtleVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICBzZXRQZW5kaW5nUmVjaXBlKG51bGwpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIElmIEVTUDMyIHNheXMgZGlzYWJsZWQsIHJlZmxlY3QgdGhhdCAoZXZlbiBpZiBVSSB0aG91Z2h0IGFjdGl2ZSlcbiAgICAgICAgICBzZXRJc1plcm9UcnVzdE1vZGUoZmFsc2UpXG4gICAgICAgICAgc2V0UGVuZGluZ1JlY2lwZShudWxsKVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG5cbiAgICAgIGNhc2UgJ3JlY2lwZV9zd2l0Y2hlZCc6IHtcbiAgICAgICAgLy8gRVNQMzIgY29tbWl0IGV2ZW50IChhdXRob3JpdGF0aXZlKVxuICAgICAgICBjb25zdCBuZXdSID0gKGRhdGEubmV3UmVjaXBlIHx8IGRhdGEucmVjaXBlIHx8IGRhdGEuY3VycmVudFJlY2lwZSkgYXMgc3RyaW5nIHwgdW5kZWZpbmVkXG4gICAgICAgIGNvbnN0IG9sZFIgPSAoZGF0YS5vbGRSZWNpcGUpIGFzIHN0cmluZyB8IHVuZGVmaW5lZFxuICAgICAgICBjb25zdCByZWFzb24gPSAoZGF0YS5yZWFzb24pIGFzIHN0cmluZyB8IHVuZGVmaW5lZFxuICAgICAgICBpZiAobmV3Uikge1xuICAgICAgICAgIGNvbnN0IHVwcGVyID0gU3RyaW5nKG5ld1IpLnRvVXBwZXJDYXNlKClcbiAgICAgICAgICBpZiAoWydGVUxMX1NUQUNLJywgJ0NIQUNIQV9IRUFWWScsICdTQUxTQV9MSUdIVCcsICdDSEFPU19PTkxZJywgJ1NUUkVBTV9GT0NVUyddLmluY2x1ZGVzKHVwcGVyKSkge1xuICAgICAgICAgICAgc2V0QWN0aXZlUmVjaXBlKHVwcGVyIGFzIFpUTVJlY2lwZUtleSlcbiAgICAgICAgICAgIHNldFBlbmRpbmdSZWNpcGUobnVsbClcbiAgICAgICAgICAgIHNldExhc3RTd2l0Y2hSZWFzb24ocmVhc29uIHx8IGBTd2l0Y2hlZCB0byAke3VwcGVyfWApXG4gICAgICAgICAgICBzZXRMYXN0U3dpdGNoVGltZShEYXRlLm5vdygpKVxuICAgICAgICAgICAgYWRkRXZlbnRMb2coe1xuICAgICAgICAgICAgICB0eXBlOiAncmVjaXBlX3N3aXRjaCcsXG4gICAgICAgICAgICAgIG1lc3NhZ2U6IGBSZWNpcGUgY29tbWl0dGVkOiAke29sZFIgPyBgJHtvbGRSfSDihpIgYCA6ICcnfSR7dXBwZXJ9JHtyZWFzb24gPyBgICgke3JlYXNvbn0pYCA6ICcnfWAsXG4gICAgICAgICAgICAgIHNvdXJjZTogJ2VzcDMyJ1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIH1cblxuICAgICAgY2FzZSAnc2VjdXJpdHlfdXBkYXRlJzpcbiAgICAgICAgaWYgKGRhdGEuZGVjcnlwdF9mYWlsdXJlcyAhPT0gdW5kZWZpbmVkIHx8IGRhdGEuaG1hY19mYWlsdXJlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdXBkYXRlSGV1cmlzdGljcyh7XG4gICAgICAgICAgICBkZWNyeXB0RmFpbHVyZXM6IGRhdGEuZGVjcnlwdF9mYWlsdXJlcyB8fCAwLFxuICAgICAgICAgICAgaG1hY0ZhaWx1cmVzOiBkYXRhLmhtYWNfZmFpbHVyZXMgfHwgMCxcbiAgICAgICAgICAgIHJlcGxheUF0dGVtcHRzOiBkYXRhLnJlcGxheV9hdHRlbXB0cyB8fCAwXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgICBicmVha1xuXG4gICAgICBjYXNlICdkZWNyeXB0aW9uX3VwZGF0ZSc6XG4gICAgICAgIC8vIEV4dHJhY3QgbGl2ZSBsYXRlbmN5IGZyb20gYWN0dWFsIGRlY3J5cHRpb24gdGltZVxuICAgICAgICBpZiAoZGF0YS5kZWNyeXB0aW9uVGltZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdXBkYXRlSGV1cmlzdGljcyh7XG4gICAgICAgICAgICBsYXRlbmN5TXM6IGRhdGEuZGVjcnlwdGlvblRpbWVcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICAgIC8vIExvZyB0aGUgZGVjcnlwdGlvbiBldmVudFxuICAgICAgICBhZGRFdmVudExvZyh7XG4gICAgICAgICAgdHlwZTogJ2hlYWx0aCcsXG4gICAgICAgICAgbWVzc2FnZTogYERhdGEgZGVjcnlwdGVkIGluICR7ZGF0YS5kZWNyeXB0aW9uVGltZT8udG9GaXhlZCgyKX1tc2AsXG4gICAgICAgICAgc291cmNlOiAnc2VydmVyJyxcbiAgICAgICAgICBkZXRhaWxzOiB7XG4gICAgICAgICAgICBwbGFpbnRleHRMZW5ndGg6IGRhdGEuZmluYWxQbGFpbnRleHQ/Lmxlbmd0aFxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSAnaGVhbHRoX2RhdGFfdXBkYXRlJzpcbiAgICAgICAgLy8gTG9nIGhlYWx0aCBkYXRhIGZyb20gRVNQMzJcbiAgICAgICAgYWRkRXZlbnRMb2coe1xuICAgICAgICAgIHR5cGU6ICdoZWFsdGgnLFxuICAgICAgICAgIG1lc3NhZ2U6IGBIZWFsdGg6IEhSPSR7ZGF0YS5oZWFydFJhdGV9IFNQTzI9JHtkYXRhLnNwbzJ9IFN0ZXBzPSR7ZGF0YS5zdGVwc31gLFxuICAgICAgICAgIHNvdXJjZTogJ2VzcDMyJ1xuICAgICAgICB9KVxuICAgICAgICBicmVha1xuICAgIH1cbiAgfSwgW2xhc3RNZXNzYWdlLCBpc1plcm9UcnVzdE1vZGUsIHVwZGF0ZUhldXJpc3RpY3MsIGFkZEFsZXJ0LCBhZGRFdmVudExvZ10pXG5cbiAgY29uc3QgdmFsdWU6IFplcm9UcnVzdENvbnRleHRUeXBlID0ge1xuICAgIGlzWmVyb1RydXN0TW9kZSxcbiAgICBpc1Bhc3NrZXlWZXJpZmllZCxcbiAgICB2ZXJpZnlQYXNza2V5LFxuICAgIGVuYWJsZVplcm9UcnVzdCxcbiAgICBkaXNhYmxlWmVyb1RydXN0LFxuICAgIGFjdGl2ZVJlY2lwZSxcbiAgICBzd2l0Y2hSZWNpcGUsXG4gICAgbGFzdFN3aXRjaFJlYXNvbixcbiAgICBsYXN0U3dpdGNoVGltZSxcbiAgICBoZXVyaXN0aWNzLFxuICAgIHVwZGF0ZUhldXJpc3RpY3MsXG4gICAgYWxlcnRzLFxuICAgIGFkZEFsZXJ0LFxuICAgIGRpc21pc3NBbGVydCxcbiAgICBjbGVhckFsZXJ0cyxcbiAgICBldmVudExvZ3MsXG4gICAgYWRkRXZlbnRMb2csXG4gICAgY2xlYXJFdmVudExvZ3MsXG4gICAgemVyb1RydXN0RGF0YVxuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8WmVyb1RydXN0Q29udGV4dC5Qcm92aWRlciB2YWx1ZT17dmFsdWV9PlxuICAgICAge2NoaWxkcmVufVxuICAgIDwvWmVyb1RydXN0Q29udGV4dC5Qcm92aWRlcj5cbiAgKVxufVxuXG4vLyBIb29rIHRvIHVzZSBaZXJvIFRydXN0IGNvbnRleHRcbmV4cG9ydCBmdW5jdGlvbiB1c2VaZXJvVHJ1c3QoKTogWmVyb1RydXN0Q29udGV4dFR5cGUge1xuICBjb25zdCBjb250ZXh0ID0gdXNlQ29udGV4dChaZXJvVHJ1c3RDb250ZXh0KVxuXG4gIGlmIChjb250ZXh0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3VzZVplcm9UcnVzdCBtdXN0IGJlIHVzZWQgd2l0aGluIGEgWmVyb1RydXN0UHJvdmlkZXInKVxuICB9XG5cbiAgcmV0dXJuIGNvbnRleHRcbn1cblxuLy8gSG9vayBmb3Igc2VjdXJpdHkgbW9uaXRvcmluZyBjb21wb25lbnRzXG5leHBvcnQgZnVuY3Rpb24gdXNlWmVyb1RydXN0U2VjdXJpdHkoKSB7XG4gIGNvbnN0IHsgaXNaZXJvVHJ1c3RNb2RlLCB6ZXJvVHJ1c3REYXRhLCBoZXVyaXN0aWNzLCBhbGVydHMgfSA9IHVzZVplcm9UcnVzdCgpXG5cbiAgY29uc3QgZ2V0U2VjdXJpdHlTdGF0dXMgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzQWN0aXZlOiBpc1plcm9UcnVzdE1vZGUsXG4gICAgICB0aHJlYXRMZXZlbDogemVyb1RydXN0RGF0YS50aHJlYXRMZXZlbCxcbiAgICAgIGFjdGl2ZUFsZXJ0czogYWxlcnRzLmxlbmd0aCxcbiAgICAgIGhldXJpc3RpY3NcbiAgICB9XG4gIH0sIFtpc1plcm9UcnVzdE1vZGUsIHplcm9UcnVzdERhdGEudGhyZWF0TGV2ZWwsIGFsZXJ0cy5sZW5ndGgsIGhldXJpc3RpY3NdKVxuXG4gIHJldHVybiB7XG4gICAgc2VjdXJpdHlTdGF0dXM6IGdldFNlY3VyaXR5U3RhdHVzKCksXG4gICAgaXNaZXJvVHJ1c3RNb2RlLFxuICAgIHplcm9UcnVzdERhdGEsXG4gICAgaGV1cmlzdGljcyxcbiAgICBhbGVydHNcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBaZXJvVHJ1c3RDb250ZXh0Il0sIm5hbWVzIjpbIlJlYWN0IiwiY3JlYXRlQ29udGV4dCIsInVzZUNvbnRleHQiLCJ1c2VTdGF0ZSIsInVzZUNhbGxiYWNrIiwidXNlRWZmZWN0IiwidXNlUmVmIiwidXNlV2ViU29ja2V0IiwiY2hlY2tUaHJlc2hvbGRzIiwiY2FuVHJpZ2dlckFsZXJ0IiwiWmVyb1RydXN0Q29udGV4dCIsInVuZGVmaW5lZCIsIkRFRkFVTFRfSEVVUklTVElDUyIsImxhdGVuY3lNcyIsImVudHJvcHlBZnRlciIsIm1lbW9yeVBlcmNlbnQiLCJjcHVQZXJjZW50IiwiaG1hY0ZhaWx1cmVzIiwiZGVjcnlwdEZhaWx1cmVzIiwicmVwbGF5QXR0ZW1wdHMiLCJtYWxmb3JtZWRQYWNrZXRzIiwidGltaW5nQW5vbWFsaWVzIiwiWmVyb1RydXN0UHJvdmlkZXIiLCJjaGlsZHJlbiIsImxhc3RNZXNzYWdlIiwic2VuZE1lc3NhZ2UiLCJpc1plcm9UcnVzdE1vZGUiLCJzZXRJc1plcm9UcnVzdE1vZGUiLCJpc1Bhc3NrZXlWZXJpZmllZCIsInNldElzUGFzc2tleVZlcmlmaWVkIiwiYWN0aXZlUmVjaXBlIiwic2V0QWN0aXZlUmVjaXBlIiwicGVuZGluZ1JlY2lwZSIsInNldFBlbmRpbmdSZWNpcGUiLCJsYXN0U3dpdGNoUmVhc29uIiwic2V0TGFzdFN3aXRjaFJlYXNvbiIsImxhc3RTd2l0Y2hUaW1lIiwic2V0TGFzdFN3aXRjaFRpbWUiLCJoZXVyaXN0aWNzIiwic2V0SGV1cmlzdGljcyIsImFsZXJ0cyIsInNldEFsZXJ0cyIsImV2ZW50TG9ncyIsInNldEV2ZW50TG9ncyIsInplcm9UcnVzdERhdGEiLCJzZXRaZXJvVHJ1c3REYXRhIiwidGhyZWF0TGV2ZWwiLCJ2ZXJpZnlQYXNza2V5IiwicGFzc2tleSIsImNvcnJlY3RQYXNza2V5IiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX1pUTV9QQVNTS0VZIiwiYWRkRXZlbnRMb2ciLCJ0eXBlIiwibWVzc2FnZSIsInNvdXJjZSIsImVuYWJsZVplcm9UcnVzdCIsImNvbnNvbGUiLCJsb2ciLCJzZXNzaW9uS2V5IiwiQXJyYXkiLCJmcm9tIiwibGVuZ3RoIiwiTWF0aCIsImZsb29yIiwicmFuZG9tIiwidG9TdHJpbmciLCJwYWRTdGFydCIsImpvaW4iLCJ3b3JkcyIsImVwaGVtZXJhbElkZW50aXR5IiwiRGF0ZSIsIm5vdyIsImZpbmFsUGFzc2tleSIsImluaXRpYWxSZWNpcGUiLCJkZXRhaWxzIiwiZGlzYWJsZVplcm9UcnVzdCIsInN3aXRjaFJlY2lwZSIsInJlY2lwZSIsInJlYXNvbiIsInN3aXRjaFJlYXNvbiIsIm1vZGUiLCJ0b1VwcGVyQ2FzZSIsInBlbmRpbmciLCJ1cGRhdGVIZXVyaXN0aWNzIiwibWV0cmljcyIsInByZXYiLCJsYXN0VGhyZXNob2xkQ2hlY2siLCJjdXJyZW50IiwidHJpZ2dlcnMiLCJ0cmlnZ2VyIiwicHJvZmlsZSIsIm5hbWUiLCJjb29sZG93blNlY29uZHMiLCJuZXdBbGVydCIsImlkIiwic3Vic3RyIiwidGltZXN0YW1wIiwic2V2ZXJpdHkiLCJhdHRhY2tUeXBlIiwiZGlzcGxheU5hbWUiLCJtZXRyaWMiLCJ2YWx1ZSIsInRocmVzaG9sZCIsInRhcmdldFJlY2lwZSIsInNsaWNlIiwiYXV0b1N3aXRjaCIsImFkZEFsZXJ0IiwiYWxlcnQiLCJkaXNtaXNzQWxlcnQiLCJmaWx0ZXIiLCJhIiwiY2xlYXJBbGVydHMiLCJlbnRyeSIsIm5ld0VudHJ5IiwiY2xlYXJFdmVudExvZ3MiLCJkYXRhIiwic3VjY2VzcyIsInIiLCJjdXJyZW50UmVjaXBlIiwidXBwZXIiLCJTdHJpbmciLCJpbmNsdWRlcyIsImVycm9yIiwicmVjaXBlU3dpdGNoZWQiLCJlbmFibGVkIiwiYWN0aXZlIiwienRtRW5hYmxlZCIsImVwb2NoIiwibmV3UiIsIm5ld1JlY2lwZSIsIm9sZFIiLCJvbGRSZWNpcGUiLCJkZWNyeXB0X2ZhaWx1cmVzIiwiaG1hY19mYWlsdXJlcyIsInJlcGxheV9hdHRlbXB0cyIsImRlY3J5cHRpb25UaW1lIiwidG9GaXhlZCIsInBsYWludGV4dExlbmd0aCIsImZpbmFsUGxhaW50ZXh0IiwiaGVhcnRSYXRlIiwic3BvMiIsInN0ZXBzIiwiUHJvdmlkZXIiLCJ1c2VaZXJvVHJ1c3QiLCJjb250ZXh0IiwiRXJyb3IiLCJ1c2VaZXJvVHJ1c3RTZWN1cml0eSIsImdldFNlY3VyaXR5U3RhdHVzIiwiaXNBY3RpdmUiLCJhY3RpdmVBbGVydHMiLCJzZWN1cml0eVN0YXR1cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./context/ZeroTrustContext.tsx\n"));

/***/ })

});