"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./context/ZeroTrustContext.tsx":
/*!**************************************!*\
  !*** ./context/ZeroTrustContext.tsx ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ZeroTrustProvider: function() { return /* binding */ ZeroTrustProvider; },\n/* harmony export */   useZeroTrust: function() { return /* binding */ useZeroTrust; },\n/* harmony export */   useZeroTrustSecurity: function() { return /* binding */ useZeroTrustSecurity; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _WebSocketContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./WebSocketContext */ \"(app-pages-browser)/./context/WebSocketContext.tsx\");\n/* harmony import */ var _lib_heuristics_thresholds__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib/heuristics-thresholds */ \"(app-pages-browser)/./lib/heuristics-thresholds.ts\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n// context/ZeroTrustContext.tsx\n/* __next_internal_client_entry_do_not_use__ ZeroTrustProvider,useZeroTrust,useZeroTrustSecurity,default auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$(), _s2 = $RefreshSig$();\n\n\n\nconst ZeroTrustContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\n// Default heuristics matching heuristics.json baseline\nconst DEFAULT_HEURISTICS = {\n    latencyMs: 48.5,\n    entropyAfter: 7.8,\n    memoryPercent: 0.204,\n    cpuPercent: 0.0,\n    hmacFailures: 0,\n    decryptFailures: 0,\n    replayAttempts: 0,\n    malformedPackets: 0,\n    timingAnomalies: 0\n};\nfunction ZeroTrustProvider(param) {\n    let { children } = param;\n    _s();\n    const { lastMessage, sendMessage } = (0,_WebSocketContext__WEBPACK_IMPORTED_MODULE_2__.useWebSocket)();\n    // Core state\n    const [isZeroTrustMode, setIsZeroTrustMode] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [isPasskeyVerified, setIsPasskeyVerified] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // Recipe state\n    // Note: this is UI state; the ESP32 is the source of truth. We reconcile on WS events.\n    const [activeRecipe, setActiveRecipe] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"CHAOS_ONLY\");\n    const [pendingRecipe, setPendingRecipe] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [lastSwitchReason, setLastSwitchReason] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [lastSwitchTime, setLastSwitchTime] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    // Heuristics state\n    const [heuristics, setHeuristics] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(DEFAULT_HEURISTICS);\n    // Alerts state\n    const [alerts, setAlerts] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    // Event logs state\n    const [eventLogs, setEventLogs] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    // Legacy data\n    const [zeroTrustData, setZeroTrustData] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        threatLevel: \"green\"\n    });\n    // Passkey verification\n    const verifyPasskey = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(async (passkey)=>{\n        const correctPasskey = process.env.NEXT_PUBLIC_ZTM_PASSKEY || \"1234\";\n        if (passkey === correctPasskey) {\n            setIsPasskeyVerified(true);\n            addEventLog({\n                type: \"success\",\n                message: \"ZTM passkey verified successfully\",\n                source: \"ztm\"\n            });\n            return true;\n        }\n        addEventLog({\n            type: \"warning\",\n            message: \"Invalid ZTM passkey attempt\",\n            source: \"ztm\"\n        });\n        return false;\n    }, []);\n    // Enable ZTM\n    const enableZeroTrust = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((passkey)=>{\n        console.log(\"[Zero Trust] \\uD83D\\uDE80 Activating Zero Trust Mode...\");\n        // Generate ephemeral session data\n        const sessionKey = Array.from({\n            length: 32\n        }, ()=>Math.floor(Math.random() * 256).toString(16).padStart(2, \"0\")).join(\"\");\n        const words = [\n            \"quantum\",\n            \"lattice\",\n            \"cipher\",\n            \"void\",\n            \"neon\",\n            \"trust\",\n            \"zero\",\n            \"burn\",\n            \"crypto\",\n            \"secure\",\n            \"ghost\",\n            \"shadow\",\n            \"black\",\n            \"red\",\n            \"green\",\n            \"pulse\"\n        ];\n        const ephemeralIdentity = Array.from({\n            length: 4\n        }, ()=>words[Math.floor(Math.random() * words.length)]).join(\"-\");\n        setZeroTrustData({\n            sessionKey,\n            ephemeralIdentity,\n            threatLevel: \"yellow\"\n        });\n        setIsZeroTrustMode(true);\n        // Request baseline recipe; ESP32 will confirm via ztm_activation_acknowledged/ztm_status\n        setPendingRecipe(\"CHAOS_ONLY\");\n        setLastSwitchReason(\"ZTM activation - starting with baseline recipe\");\n        setLastSwitchTime(Date.now());\n        // Send activation to backend\n        // Include passkey for server-side verification (default to '1234' if not provided)\n        const finalPasskey = passkey || process.env.NEXT_PUBLIC_ZTM_PASSKEY || \"1234\";\n        sendMessage({\n            type: \"ztm_activate_request\",\n            passkey: finalPasskey,\n            sessionKey,\n            ephemeralIdentity,\n            initialRecipe: \"CHAOS_ONLY\"\n        });\n        addEventLog({\n            type: \"recipe_switch\",\n            message: \"Zero Trust Mode activated with CHAOS_ONLY baseline\",\n            source: \"ztm\",\n            details: {\n                ephemeralIdentity\n            }\n        });\n        console.log(\"[Zero Trust] ✅ Mode activated with ephemeral identity:\", ephemeralIdentity);\n    }, [\n        sendMessage\n    ]);\n    // Disable ZTM\n    const disableZeroTrust = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        console.log(\"[Zero Trust] \\uD83D\\uDDD1️ Deactivating Zero Trust Mode...\");\n        sendMessage({\n            type: \"ztm_deactivate_request\"\n        });\n        addEventLog({\n            type: \"info\",\n            message: \"Zero Trust Mode deactivated - returning to Normal Mode\",\n            source: \"ztm\"\n        });\n        setZeroTrustData({\n            threatLevel: \"green\"\n        });\n        setIsZeroTrustMode(false);\n        setIsPasskeyVerified(false);\n        setActiveRecipe(\"CHAOS_ONLY\");\n        setPendingRecipe(null);\n        setLastSwitchReason(null);\n        setLastSwitchTime(null);\n        setHeuristics(DEFAULT_HEURISTICS);\n        console.log(\"[Zero Trust] ✅ Mode deactivated, all data destroyed\");\n    }, [\n        sendMessage\n    ]);\n    // Switch recipe\n    const switchRecipe = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((recipe, reason)=>{\n        // Cooldown check (5 seconds minimum)\n        if (lastSwitchTime && Date.now() - lastSwitchTime < 5000) {\n            addEventLog({\n                type: \"warning\",\n                message: \"Recipe switch blocked - cooldown active (5s minimum)\",\n                source: \"ztm\"\n            });\n            return;\n        }\n        const switchReason = reason || \"Manual switch to \".concat(recipe);\n        // Do not immediately claim the recipe is active; wait for ESP32 confirmation\n        setPendingRecipe(recipe);\n        setLastSwitchReason(switchReason);\n        setLastSwitchTime(Date.now());\n        sendMessage({\n            type: \"adaptive_switch_request\",\n            mode: \"ztm\",\n            recipe: recipe.toUpperCase() // Server expects uppercase: CHAOS_ONLY, SALSA_LIGHT, etc.\n        });\n        addEventLog({\n            type: \"recipe_switch\",\n            message: \"Switch requested → \".concat(recipe, \": \").concat(switchReason),\n            source: \"ztm\",\n            details: {\n                recipe,\n                reason: switchReason,\n                pending: true\n            }\n        });\n        console.log(\"[Zero Trust] ⚡ Recipe switched to \".concat(recipe, \": \").concat(switchReason));\n    }, [\n        lastSwitchTime,\n        sendMessage\n    ]);\n    // Update heuristics\n    const updateHeuristics = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((metrics)=>{\n        setHeuristics((prev)=>({\n                ...prev,\n                ...metrics\n            }));\n    }, []);\n    // Track last threshold check to avoid duplicate alerts\n    const lastThresholdCheck = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(0);\n    // Check thresholds on heuristics change - works in BOTH Normal and ZTM modes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const now = Date.now();\n        // Only check every 2 seconds to prevent spam\n        if (now - lastThresholdCheck.current < 2000) return;\n        lastThresholdCheck.current = now;\n        // Check thresholds against current heuristics\n        const triggers = (0,_lib_heuristics_thresholds__WEBPACK_IMPORTED_MODULE_3__.checkThresholds)(heuristics);\n        for (const trigger of triggers){\n            // Check cooldown to prevent duplicate alerts\n            if (!(0,_lib_heuristics_thresholds__WEBPACK_IMPORTED_MODULE_3__.canTriggerAlert)(trigger.profile.name, trigger.profile.cooldownSeconds)) {\n                continue;\n            }\n            // Generate alert (works in both modes)\n            const newAlert = {\n                id: \"alert-\".concat(Date.now(), \"-\").concat(Math.random().toString(36).substr(2, 9)),\n                timestamp: Date.now(),\n                type: trigger.profile.severity,\n                attackType: trigger.profile.displayName,\n                message: trigger.profile.reason,\n                metric: trigger.metric,\n                value: trigger.value,\n                threshold: trigger.threshold,\n                recipe: isZeroTrustMode ? trigger.profile.targetRecipe : undefined\n            };\n            setAlerts((prev)=>[\n                    newAlert,\n                    ...prev\n                ].slice(0, 50));\n            // Log the alert\n            addEventLog({\n                type: \"threat\",\n                message: \"\".concat(trigger.profile.displayName, \": \").concat(trigger.profile.reason),\n                source: isZeroTrustMode ? \"ztm\" : \"system\",\n                details: {\n                    metric: trigger.metric,\n                    value: trigger.value,\n                    threshold: trigger.threshold,\n                    mode: isZeroTrustMode ? \"ZTM\" : \"NORMAL\"\n                }\n            });\n            // Only auto-switch recipe in ZTM mode\n            if (isZeroTrustMode && trigger.profile.targetRecipe) {\n                switchRecipe(trigger.profile.targetRecipe, trigger.profile.reason);\n            }\n            console.log(\"[Alert] \".concat(isZeroTrustMode ? \"\\uD83D\\uDD34 ZTM\" : \"\\uD83D\\uDFE1 Normal\", \": \").concat(trigger.profile.displayName), {\n                metric: trigger.metric,\n                value: trigger.value,\n                threshold: trigger.threshold,\n                autoSwitch: isZeroTrustMode\n            });\n        }\n    }, [\n        heuristics,\n        isZeroTrustMode\n    ]);\n    // Add alert\n    const addAlert = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((alert)=>{\n        const newAlert = {\n            ...alert,\n            id: \"alert-\".concat(Date.now(), \"-\").concat(Math.random().toString(36).substr(2, 9)),\n            timestamp: Date.now()\n        };\n        setAlerts((prev)=>[\n                newAlert,\n                ...prev\n            ].slice(0, 50)) // Keep max 50 alerts\n        ;\n        // Also log to event log\n        addEventLog({\n            type: \"threat\",\n            message: \"\".concat(alert.attackType, \": \").concat(alert.message),\n            source: \"ztm\",\n            details: {\n                metric: alert.metric,\n                value: alert.value,\n                threshold: alert.threshold\n            }\n        });\n    }, []);\n    const dismissAlert = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((id)=>{\n        setAlerts((prev)=>prev.filter((a)=>a.id !== id));\n    }, []);\n    const clearAlerts = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        setAlerts([]);\n    }, []);\n    // Add event log\n    const addEventLog = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((entry)=>{\n        const newEntry = {\n            ...entry,\n            id: \"log-\".concat(Date.now(), \"-\").concat(Math.random().toString(36).substr(2, 9)),\n            timestamp: Date.now()\n        };\n        setEventLogs((prev)=>[\n                ...prev,\n                newEntry\n            ].slice(-100)) // Keep last 100 logs\n        ;\n    }, []);\n    const clearEventLogs = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        setEventLogs([]);\n    }, []);\n    // Listen for WebSocket messages\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!lastMessage) return;\n        const { type, ...data } = lastMessage;\n        switch(type){\n            case \"ztm_activation_acknowledged\":\n                if (data.success) {\n                    setZeroTrustData((prev)=>({\n                            ...prev,\n                            threatLevel: \"green\"\n                        }));\n                    // Prefer ESP32-provided recipe fields (currentRecipe/recipe)\n                    const r = data.currentRecipe || data.recipe;\n                    if (r) {\n                        const upper = String(r).toUpperCase();\n                        if ([\n                            \"FULL_STACK\",\n                            \"CHACHA_HEAVY\",\n                            \"SALSA_LIGHT\",\n                            \"CHAOS_ONLY\",\n                            \"STREAM_FOCUS\"\n                        ].includes(upper)) {\n                            setActiveRecipe(upper);\n                            setPendingRecipe(null);\n                        }\n                    }\n                    addEventLog({\n                        type: \"success\",\n                        message: \"ZTM activation acknowledged (recipe=\".concat(data.currentRecipe || data.recipe || \"unknown\", \")\"),\n                        source: \"server\"\n                    });\n                } else {\n                    setPendingRecipe(null);\n                    addEventLog({\n                        type: \"error\",\n                        message: \"ZTM activation rejected: \".concat(data.error || \"unknown error\"),\n                        source: \"server\"\n                    });\n                }\n                break;\n            case \"adaptive_switch_acknowledged\":\n                // This is a broadcast; treat as informational (ESP32 will emit recipe_switched on commit)\n                addEventLog({\n                    type: data.success === false ? \"warning\" : \"info\",\n                    message: \"Switch ack broadcast: mode=\".concat(data.mode || \"ztm\", \" recipe=\").concat(data.recipe || \"unknown\", \" success=\").concat(data.success !== false),\n                    source: \"server\"\n                });\n                break;\n            case \"heuristics_update\":\n                updateHeuristics(data.metrics);\n                break;\n            case \"threat_alert\":\n                addAlert({\n                    type: data.severity || \"warning\",\n                    attackType: data.attackType,\n                    message: data.message,\n                    metric: data.metric,\n                    value: data.value,\n                    threshold: data.threshold,\n                    recipe: data.recipeSwitched\n                });\n                // Auto-switch recipe in ZTM mode\n                if (isZeroTrustMode && data.recipeSwitched) {\n                    setActiveRecipe(data.recipeSwitched);\n                    setLastSwitchReason(data.reason || \"Automatic threat response\");\n                    setLastSwitchTime(Date.now());\n                }\n                break;\n            case \"ztm_status\":\n            case \"ztm_status_update\":\n                {\n                    // ESP32 periodic/current status (source of truth)\n                    const enabled = !!data.ztmEnabled;\n                    const r = data.currentRecipe || data.recipe;\n                    if (enabled) {\n                        setIsZeroTrustMode(true);\n                        if (r) {\n                            const upper = String(r).toUpperCase();\n                            if ([\n                                \"FULL_STACK\",\n                                \"CHACHA_HEAVY\",\n                                \"SALSA_LIGHT\",\n                                \"CHAOS_ONLY\",\n                                \"STREAM_FOCUS\"\n                            ].includes(upper)) {\n                                // If recipe actually changed, log it as a committed switch\n                                setActiveRecipe((prev)=>{\n                                    if (prev !== upper) {\n                                        addEventLog({\n                                            type: \"recipe_switch\",\n                                            message: \"Recipe committed: \".concat(prev, \" → \").concat(upper),\n                                            source: \"server\",\n                                            details: {\n                                                epoch: data.epoch,\n                                                reason: data.lastSwitchReason\n                                            }\n                                        });\n                                        setLastSwitchReason(data.lastSwitchReason || \"Switched to \".concat(upper));\n                                        setLastSwitchTime(Date.now());\n                                    }\n                                    return upper;\n                                });\n                                setPendingRecipe(null);\n                            }\n                        }\n                    } else {\n                        // If ESP32 says disabled, reflect that (even if UI thought active)\n                        setIsZeroTrustMode(false);\n                        setPendingRecipe(null);\n                    }\n                    break;\n                }\n            case \"recipe_switched\":\n                {\n                    // ESP32 commit event (authoritative)\n                    const newR = data.newRecipe || data.recipe || data.currentRecipe;\n                    const oldR = data.oldRecipe;\n                    const reason = data.reason;\n                    if (newR) {\n                        const upper = String(newR).toUpperCase();\n                        if ([\n                            \"FULL_STACK\",\n                            \"CHACHA_HEAVY\",\n                            \"SALSA_LIGHT\",\n                            \"CHAOS_ONLY\",\n                            \"STREAM_FOCUS\"\n                        ].includes(upper)) {\n                            setActiveRecipe(upper);\n                            setPendingRecipe(null);\n                            setLastSwitchReason(reason || \"Switched to \".concat(upper));\n                            setLastSwitchTime(Date.now());\n                            addEventLog({\n                                type: \"recipe_switch\",\n                                message: \"Recipe committed: \".concat(oldR ? \"\".concat(oldR, \" → \") : \"\").concat(upper).concat(reason ? \" (\".concat(reason, \")\") : \"\"),\n                                source: \"esp32\"\n                            });\n                        }\n                    }\n                    break;\n                }\n            case \"security_update\":\n                if (data.decrypt_failures !== undefined || data.hmac_failures !== undefined) {\n                    updateHeuristics({\n                        decryptFailures: data.decrypt_failures || 0,\n                        hmacFailures: data.hmac_failures || 0,\n                        replayAttempts: data.replay_attempts || 0\n                    });\n                }\n                break;\n            case \"decryption_update\":\n                var _data_decryptionTime, _data_finalPlaintext;\n                // Extract live latency from actual decryption time\n                if (data.decryptionTime !== undefined) {\n                    updateHeuristics({\n                        latencyMs: data.decryptionTime\n                    });\n                }\n                // Log the decryption event\n                addEventLog({\n                    type: \"health\",\n                    message: \"Data decrypted in \".concat((_data_decryptionTime = data.decryptionTime) === null || _data_decryptionTime === void 0 ? void 0 : _data_decryptionTime.toFixed(2), \"ms\"),\n                    source: \"server\",\n                    details: {\n                        plaintextLength: (_data_finalPlaintext = data.finalPlaintext) === null || _data_finalPlaintext === void 0 ? void 0 : _data_finalPlaintext.length\n                    }\n                });\n                break;\n            case \"health_data_update\":\n                // Log health data from ESP32\n                addEventLog({\n                    type: \"health\",\n                    message: \"Health: HR=\".concat(data.heartRate, \" SPO2=\").concat(data.spo2, \" Steps=\").concat(data.steps),\n                    source: \"esp32\"\n                });\n                break;\n        }\n    }, [\n        lastMessage,\n        isZeroTrustMode,\n        updateHeuristics,\n        addAlert,\n        addEventLog\n    ]);\n    const value = {\n        isZeroTrustMode,\n        isPasskeyVerified,\n        verifyPasskey,\n        enableZeroTrust,\n        disableZeroTrust,\n        activeRecipe,\n        switchRecipe,\n        lastSwitchReason,\n        lastSwitchTime,\n        heuristics,\n        updateHeuristics,\n        alerts,\n        addAlert,\n        dismissAlert,\n        clearAlerts,\n        eventLogs,\n        addEventLog,\n        clearEventLogs,\n        zeroTrustData\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(ZeroTrustContext.Provider, {\n        value: value,\n        children: children\n    }, void 0, false, {\n        fileName: \"D:\\\\Projects\\\\XHI2\\\\XenoCipher_Healthcare_IoT\\\\xenocipher-frontend\\\\context\\\\ZeroTrustContext.tsx\",\n        lineNumber: 531,\n        columnNumber: 5\n    }, this);\n}\n_s(ZeroTrustProvider, \"GpxaFH2zxbSSM+U5KAlJCJkJ8SM=\", false, function() {\n    return [\n        _WebSocketContext__WEBPACK_IMPORTED_MODULE_2__.useWebSocket\n    ];\n});\n_c = ZeroTrustProvider;\n// Hook to use Zero Trust context\nfunction useZeroTrust() {\n    _s1();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(ZeroTrustContext);\n    if (context === undefined) {\n        throw new Error(\"useZeroTrust must be used within a ZeroTrustProvider\");\n    }\n    return context;\n}\n_s1(useZeroTrust, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\n// Hook for security monitoring components\nfunction useZeroTrustSecurity() {\n    _s2();\n    const { isZeroTrustMode, zeroTrustData, heuristics, alerts } = useZeroTrust();\n    const getSecurityStatus = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        return {\n            isActive: isZeroTrustMode,\n            threatLevel: zeroTrustData.threatLevel,\n            activeAlerts: alerts.length,\n            heuristics\n        };\n    }, [\n        isZeroTrustMode,\n        zeroTrustData.threatLevel,\n        alerts.length,\n        heuristics\n    ]);\n    return {\n        securityStatus: getSecurityStatus(),\n        isZeroTrustMode,\n        zeroTrustData,\n        heuristics,\n        alerts\n    };\n}\n_s2(useZeroTrustSecurity, \"6z0EI+ALph9kvylCE9Hiv3OSI78=\", false, function() {\n    return [\n        useZeroTrust\n    ];\n});\n/* harmony default export */ __webpack_exports__[\"default\"] = (ZeroTrustContext);\nvar _c;\n$RefreshReg$(_c, \"ZeroTrustProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbnRleHQvWmVyb1RydXN0Q29udGV4dC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUEsK0JBQStCOzs7QUFHOEU7QUFDNUQ7QUFDeUU7QUErQzFILE1BQU1VLGlDQUFtQlQsb0RBQWFBLENBQW1DVTtBQU16RSx1REFBdUQ7QUFDdkQsTUFBTUMscUJBQXVDO0lBQzNDQyxXQUFXO0lBQ1hDLGNBQWM7SUFDZEMsZUFBZTtJQUNmQyxZQUFZO0lBQ1pDLGNBQWM7SUFDZEMsaUJBQWlCO0lBQ2pCQyxnQkFBZ0I7SUFDaEJDLGtCQUFrQjtJQUNsQkMsaUJBQWlCO0FBQ25CO0FBRU8sU0FBU0Msa0JBQWtCLEtBQW9DO1FBQXBDLEVBQUVDLFFBQVEsRUFBMEIsR0FBcEM7O0lBQ2hDLE1BQU0sRUFBRUMsV0FBVyxFQUFFQyxXQUFXLEVBQUUsR0FBR2xCLCtEQUFZQTtJQUVqRCxhQUFhO0lBQ2IsTUFBTSxDQUFDbUIsaUJBQWlCQyxtQkFBbUIsR0FBR3hCLCtDQUFRQSxDQUFDO0lBQ3ZELE1BQU0sQ0FBQ3lCLG1CQUFtQkMscUJBQXFCLEdBQUcxQiwrQ0FBUUEsQ0FBQztJQUUzRCxlQUFlO0lBQ2YsdUZBQXVGO0lBQ3ZGLE1BQU0sQ0FBQzJCLGNBQWNDLGdCQUFnQixHQUFHNUIsK0NBQVFBLENBQWU7SUFDL0QsTUFBTSxDQUFDNkIsZUFBZUMsaUJBQWlCLEdBQUc5QiwrQ0FBUUEsQ0FBc0I7SUFDeEUsTUFBTSxDQUFDK0Isa0JBQWtCQyxvQkFBb0IsR0FBR2hDLCtDQUFRQSxDQUFnQjtJQUN4RSxNQUFNLENBQUNpQyxnQkFBZ0JDLGtCQUFrQixHQUFHbEMsK0NBQVFBLENBQWdCO0lBRXBFLG1CQUFtQjtJQUNuQixNQUFNLENBQUNtQyxZQUFZQyxjQUFjLEdBQUdwQywrQ0FBUUEsQ0FBbUJTO0lBRS9ELGVBQWU7SUFDZixNQUFNLENBQUM0QixRQUFRQyxVQUFVLEdBQUd0QywrQ0FBUUEsQ0FBZ0IsRUFBRTtJQUV0RCxtQkFB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RztRQUFDWjtRQUFpQmtCLGNBQWNFLFdBQVc7UUFBRU4sT0FBT3VCLE1BQU07UUFBRXpCO0tBQVc7SUFFMUUsT0FBTztRQUNMaUgsZ0JBQWdCSDtRQUNoQjFIO1FBQ0FrQjtRQUNBTjtRQUNBRTtJQUNGO0FBQ0Y7SUFuQmdCMkc7O1FBQ2lESDs7O0FBb0JqRSwrREFBZXRJLGdCQUFnQkEsRUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb250ZXh0L1plcm9UcnVzdENvbnRleHQudHN4PzY5ZjciXSwic291cmNlc0NvbnRlbnQiOlsiLy8gY29udGV4dC9aZXJvVHJ1c3RDb250ZXh0LnRzeFxuJ3VzZSBjbGllbnQnXG5cbmltcG9ydCBSZWFjdCwgeyBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0LCB1c2VTdGF0ZSwgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlUmVmLCBSZWFjdE5vZGUgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB7IHVzZVdlYlNvY2tldCB9IGZyb20gJy4vV2ViU29ja2V0Q29udGV4dCdcbmltcG9ydCB7IGNoZWNrVGhyZXNob2xkcywgY2FuVHJpZ2dlckFsZXJ0LCB0eXBlIEhldXJpc3RpY01ldHJpY3MgYXMgVGhyZXNob2xkTWV0cmljcyB9IGZyb20gJy4uL2xpYi9oZXVyaXN0aWNzLXRocmVzaG9sZHMnXG5pbXBvcnQgdHlwZSB7IFpUTVJlY2lwZUtleSB9IGZyb20gJy4uL2NvbXBvbmVudHMvenRtL1pUTVJlY2lwZXNQYW5lbCdcbmltcG9ydCB0eXBlIHsgSGV1cmlzdGljTWV0cmljcyB9IGZyb20gJy4uL2NvbXBvbmVudHMvenRtL1pUTVRocmVhdE1ldHJpY3NEYXNoYm9hcmQnXG5pbXBvcnQgdHlwZSB7IFRocmVhdEFsZXJ0IH0gZnJvbSAnLi4vY29tcG9uZW50cy96dG0vWlRNQWxlcnRTeXN0ZW0nXG5pbXBvcnQgdHlwZSB7IExvZ0VudHJ5IH0gZnJvbSAnLi4vY29tcG9uZW50cy96dG0vWlRNRXZlbnRMb2cnXG5cbmV4cG9ydCB0eXBlIFRocmVhdExldmVsID0gJ2dyZWVuJyB8ICd5ZWxsb3cnIHwgJ3JlZCdcblxuaW50ZXJmYWNlIFplcm9UcnVzdENvbnRleHRUeXBlIHtcbiAgLy8gQ29yZSBzdGF0ZVxuICBpc1plcm9UcnVzdE1vZGU6IGJvb2xlYW5cbiAgaXNQYXNza2V5VmVyaWZpZWQ6IGJvb2xlYW5cblxuICAvLyBBY3Rpb25zXG4gIHZlcmlmeVBhc3NrZXk6IChwYXNza2V5OiBzdHJpbmcpID0+IFByb21pc2U8Ym9vbGVhbj5cbiAgZW5hYmxlWmVyb1RydXN0OiAocGFzc2tleT86IHN0cmluZykgPT4gdm9pZFxuICBkaXNhYmxlWmVyb1RydXN0OiAoKSA9PiB2b2lkXG5cbiAgLy8gUmVjaXBlIG1hbmFnZW1lbnRcbiAgYWN0aXZlUmVjaXBlOiBaVE1SZWNpcGVLZXlcbiAgc3dpdGNoUmVjaXBlOiAocmVjaXBlOiBaVE1SZWNpcGVLZXksIHJlYXNvbj86IHN0cmluZykgPT4gdm9pZFxuICBsYXN0U3dpdGNoUmVhc29uOiBzdHJpbmcgfCBudWxsXG4gIGxhc3RTd2l0Y2hUaW1lOiBudW1iZXIgfCBudWxsXG5cbiAgLy8gSGV1cmlzdGljcyAmIE1ldHJpY3NcbiAgaGV1cmlzdGljczogSGV1cmlzdGljTWV0cmljc1xuICB1cGRhdGVIZXVyaXN0aWNzOiAobWV0cmljczogUGFydGlhbDxIZXVyaXN0aWNNZXRyaWNzPikgPT4gdm9pZFxuXG4gIC8vIEFsZXJ0c1xuICBhbGVydHM6IFRocmVhdEFsZXJ0W11cbiAgYWRkQWxlcnQ6IChhbGVydDogT21pdDxUaHJlYXRBbGVydCwgJ2lkJyB8ICd0aW1lc3RhbXAnPikgPT4gdm9pZFxuICBkaXNtaXNzQWxlcnQ6IChpZDogc3RyaW5nKSA9PiB2b2lkXG4gIGNsZWFyQWxlcnRzOiAoKSA9PiB2b2lkXG5cbiAgLy8gRXZlbnQgTG9nXG4gIGV2ZW50TG9nczogTG9nRW50cnlbXVxuICBhZGRFdmVudExvZzogKGVudHJ5OiBPbWl0PExvZ0VudHJ5LCAnaWQnIHwgJ3RpbWVzdGFtcCc+KSA9PiB2b2lkXG4gIGNsZWFyRXZlbnRMb2dzOiAoKSA9PiB2b2lkXG5cbiAgLy8gTGVnYWN5IGRhdGEgb2JqZWN0XG4gIHplcm9UcnVzdERhdGE6IHtcbiAgICBzZXNzaW9uS2V5Pzogc3RyaW5nXG4gICAgZXBoZW1lcmFsSWRlbnRpdHk/OiBzdHJpbmdcbiAgICB0aHJlYXRMZXZlbDogVGhyZWF0TGV2ZWxcbiAgfVxufVxuXG5jb25zdCBaZXJvVHJ1c3RDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxaZXJvVHJ1c3RDb250ZXh0VHlwZSB8IHVuZGVmaW5lZD4odW5kZWZpbmVkKVxuXG5pbnRlcmZhY2UgWmVyb1RydXN0UHJvdmlkZXJQcm9wcyB7XG4gIGNoaWxkcmVuOiBSZWFjdE5vZGVcbn1cblxuLy8gRGVmYXVsdCBoZXVyaXN0aWNzIG1hdGNoaW5nIGhldXJpc3RpY3MuanNvbiBiYXNlbGluZVxuY29uc3QgREVGQVVMVF9IRVVSSVNUSUNTOiBIZXVyaXN0aWNNZXRyaWNzID0ge1xuICBsYXRlbmN5TXM6IDQ4LjUsXG4gIGVudHJvcHlBZnRlcjogNy44LFxuICBtZW1vcnlQZXJjZW50OiAwLjIwNCxcbiAgY3B1UGVyY2VudDogMC4wLFxuICBobWFjRmFpbHVyZXM6IDAsXG4gIGRlY3J5cHRGYWlsdXJlczogMCxcbiAgcmVwbGF5QXR0ZW1wdHM6IDAsXG4gIG1hbGZvcm1lZFBhY2tldHM6IDAsXG4gIHRpbWluZ0Fub21hbGllczogMFxufVxuXG5leHBvcnQgZnVuY3Rpb24gWmVyb1RydXN0UHJvdmlkZXIoeyBjaGlsZHJlbiB9OiBaZXJvVHJ1c3RQcm92aWRlclByb3BzKSB7XG4gIGNvbnN0IHsgbGFzdE1lc3NhZ2UsIHNlbmRNZXNzYWdlIH0gPSB1c2VXZWJTb2NrZXQoKVxuXG4gIC8vIENvcmUgc3RhdGVcbiAgY29uc3QgW2lzWmVyb1RydXN0TW9kZSwgc2V0SXNaZXJvVHJ1c3RNb2RlXSA9IHVzZVN0YXRlKGZhbHNlKVxuICBjb25zdCBbaXNQYXNza2V5VmVyaWZpZWQsIHNldElzUGFzc2tleVZlcmlmaWVkXSA9IHVzZVN0YXRlKGZhbHNlKVxuXG4gIC8vIFJlY2lwZSBzdGF0ZVxuICAvLyBOb3RlOiB0aGlzIGlzIFVJIHN0YXRlOyB0aGUgRVNQMzIgaXMgdGhlIHNvdXJjZSBvZiB0cnV0aC4gV2UgcmVjb25jaWxlIG9uIFdTIGV2ZW50cy5cbiAgY29uc3QgW2FjdGl2ZVJlY2lwZSwgc2V0QWN0aXZlUmVjaXBlXSA9IHVzZVN0YXRlPFpUTVJlY2lwZUtleT4oJ0NIQU9TX09OTFknKVxuICBjb25zdCBbcGVuZGluZ1JlY2lwZSwgc2V0UGVuZGluZ1JlY2lwZV0gPSB1c2VTdGF0ZTxaVE1SZWNpcGVLZXkgfCBudWxsPihudWxsKVxuICBjb25zdCBbbGFzdFN3aXRjaFJlYXNvbiwgc2V0TGFzdFN3aXRjaFJlYXNvbl0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKVxuICBjb25zdCBbbGFzdFN3aXRjaFRpbWUsIHNldExhc3RTd2l0Y2hUaW1lXSA9IHVzZVN0YXRlPG51bWJlciB8IG51bGw+KG51bGwpXG5cbiAgLy8gSGV1cmlzdGljcyBzdGF0ZVxuICBjb25zdCBbaGV1cmlzdGljcywgc2V0SGV1cmlzdGljc10gPSB1c2VTdGF0ZTxIZXVyaXN0aWNNZXRyaWNzPihERUZBVUxUX0hFVVJJU1RJQ1MpXG5cbiAgLy8gQWxlcnRzIHN0YXRlXG4gIGNvbnN0IFthbGVydHMsIHNldEFsZXJ0c10gPSB1c2VTdGF0ZTxUaHJlYXRBbGVydFtdPihbXSlcblxuICAvLyBFdmVudCBsb2dzIHN0YXRlXG4gIGNvbnN0IFtldmVudExvZ3MsIHNldEV2ZW50TG9nc10gPSB1c2VTdGF0ZTxMb2dFbnRyeVtdPihbXSlcblxuICAvLyBMZWdhY3kgZGF0YVxuICBjb25zdCBbemVyb1RydXN0RGF0YSwgc2V0WmVyb1RydXN0RGF0YV0gPSB1c2VTdGF0ZTx7XG4gICAgc2Vzc2lvbktleT86IHN0cmluZ1xuICAgIGVwaGVtZXJhbElkZW50aXR5Pzogc3RyaW5nXG4gICAgdGhyZWF0TGV2ZWw6IFRocmVhdExldmVsXG4gIH0+KHsgdGhyZWF0TGV2ZWw6ICdncmVlbicgfSlcblxuICAvLyBQYXNza2V5IHZlcmlmaWNhdGlvblxuICBjb25zdCB2ZXJpZnlQYXNza2V5ID0gdXNlQ2FsbGJhY2soYXN5bmMgKHBhc3NrZXk6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4gPT4ge1xuICAgIGNvbnN0IGNvcnJlY3RQYXNza2V5ID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfWlRNX1BBU1NLRVkgfHwgJzEyMzQnXG5cbiAgICBpZiAocGFzc2tleSA9PT0gY29ycmVjdFBhc3NrZXkpIHtcbiAgICAgIHNldElzUGFzc2tleVZlcmlmaWVkKHRydWUpXG4gICAgICBhZGRFdmVudExvZyh7XG4gICAgICAgIHR5cGU6ICdzdWNjZXNzJyxcbiAgICAgICAgbWVzc2FnZTogJ1pUTSBwYXNza2V5IHZlcmlmaWVkIHN1Y2Nlc3NmdWxseScsXG4gICAgICAgIHNvdXJjZTogJ3p0bSdcbiAgICAgIH0pXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIGFkZEV2ZW50TG9nKHtcbiAgICAgIHR5cGU6ICd3YXJuaW5nJyxcbiAgICAgIG1lc3NhZ2U6ICdJbnZhbGlkIFpUTSBwYXNza2V5IGF0dGVtcHQnLFxuICAgICAgc291cmNlOiAnenRtJ1xuICAgIH0pXG4gICAgcmV0dXJuIGZhbHNlXG4gIH0sIFtdKVxuXG4gIC8vIEVuYWJsZSBaVE1cbiAgY29uc3QgZW5hYmxlWmVyb1RydXN0ID0gdXNlQ2FsbGJhY2soKHBhc3NrZXk/OiBzdHJpbmcpID0+IHtcbiAgICBjb25zb2xlLmxvZygnW1plcm8gVHJ1c3RdIPCfmoAgQWN0aXZhdGluZyBaZXJvIFRydXN0IE1vZGUuLi4nKVxuXG4gICAgLy8gR2VuZXJhdGUgZXBoZW1lcmFsIHNlc3Npb24gZGF0YVxuICAgIGNvbnN0IHNlc3Npb25LZXkgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiAzMiB9LCAoKSA9PlxuICAgICAgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjU2KS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKVxuICAgICkuam9pbignJylcblxuICAgIGNvbnN0IHdvcmRzID0gW1xuICAgICAgJ3F1YW50dW0nLCAnbGF0dGljZScsICdjaXBoZXInLCAndm9pZCcsICduZW9uJywgJ3RydXN0JywgJ3plcm8nLCAnYnVybicsXG4gICAgICAnY3J5cHRvJywgJ3NlY3VyZScsICdnaG9zdCcsICdzaGFkb3cnLCAnYmxhY2snLCAncmVkJywgJ2dyZWVuJywgJ3B1bHNlJ1xuICAgIF1cblxuICAgIGNvbnN0IGVwaGVtZXJhbElkZW50aXR5ID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogNCB9LCAoKSA9PlxuICAgICAgd29yZHNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogd29yZHMubGVuZ3RoKV1cbiAgICApLmpvaW4oJy0nKVxuXG4gICAgc2V0WmVyb1RydXN0RGF0YSh7XG4gICAgICBzZXNzaW9uS2V5LFxuICAgICAgZXBoZW1lcmFsSWRlbnRpdHksXG4gICAgICB0aHJlYXRMZXZlbDogJ3llbGxvdydcbiAgICB9KVxuICAgIHNldElzWmVyb1RydXN0TW9kZSh0cnVlKVxuICAgIC8vIFJlcXVlc3QgYmFzZWxpbmUgcmVjaXBlOyBFU1AzMiB3aWxsIGNvbmZpcm0gdmlhIHp0bV9hY3RpdmF0aW9uX2Fja25vd2xlZGdlZC96dG1fc3RhdHVzXG4gICAgc2V0UGVuZGluZ1JlY2lwZSgnQ0hBT1NfT05MWScpXG4gICAgc2V0TGFzdFN3aXRjaFJlYXNvbignWlRNIGFjdGl2YXRpb24gLSBzdGFydGluZyB3aXRoIGJhc2VsaW5lIHJlY2lwZScpXG4gICAgc2V0TGFzdFN3aXRjaFRpbWUoRGF0ZS5ub3coKSlcblxuICAgIC8vIFNlbmQgYWN0aXZhdGlvbiB0byBiYWNrZW5kXG4gICAgLy8gSW5jbHVkZSBwYXNza2V5IGZvciBzZXJ2ZXItc2lkZSB2ZXJpZmljYXRpb24gKGRlZmF1bHQgdG8gJzEyMzQnIGlmIG5vdCBwcm92aWRlZClcbiAgICBjb25zdCBmaW5hbFBhc3NrZXkgPSBwYXNza2V5IHx8IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1pUTV9QQVNTS0VZIHx8ICcxMjM0J1xuICAgIHNlbmRNZXNzYWdlKHtcbiAgICAgIHR5cGU6ICd6dG1fYWN0aXZhdGVfcmVxdWVzdCcsXG4gICAgICBwYXNza2V5OiBmaW5hbFBhc3NrZXksXG4gICAgICBzZXNzaW9uS2V5LFxuICAgICAgZXBoZW1lcmFsSWRlbnRpdHksXG4gICAgICBpbml0aWFsUmVjaXBlOiAnQ0hBT1NfT05MWSdcbiAgICB9KVxuXG4gICAgYWRkRXZlbnRMb2coe1xuICAgICAgdHlwZTogJ3JlY2lwZV9zd2l0Y2gnLFxuICAgICAgbWVzc2FnZTogJ1plcm8gVHJ1c3QgTW9kZSBhY3RpdmF0ZWQgd2l0aCBDSEFPU19PTkxZIGJhc2VsaW5lJyxcbiAgICAgIHNvdXJjZTogJ3p0bScsXG4gICAgICBkZXRhaWxzOiB7IGVwaGVtZXJhbElkZW50aXR5IH1cbiAgICB9KVxuXG4gICAgY29uc29sZS5sb2coJ1taZXJvIFRydXN0XSDinIUgTW9kZSBhY3RpdmF0ZWQgd2l0aCBlcGhlbWVyYWwgaWRlbnRpdHk6JywgZXBoZW1lcmFsSWRlbnRpdHkpXG4gIH0sIFtzZW5kTWVzc2FnZV0pXG5cbiAgLy8gRGlzYWJsZSBaVE1cbiAgY29uc3QgZGlzYWJsZVplcm9UcnVzdCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBjb25zb2xlLmxvZygnW1plcm8gVHJ1c3RdIPCfl5HvuI8gRGVhY3RpdmF0aW5nIFplcm8gVHJ1c3QgTW9kZS4uLicpXG5cbiAgICBzZW5kTWVzc2FnZSh7XG4gICAgICB0eXBlOiAnenRtX2RlYWN0aXZhdGVfcmVxdWVzdCdcbiAgICB9KVxuXG4gICAgYWRkRXZlbnRMb2coe1xuICAgICAgdHlwZTogJ2luZm8nLFxuICAgICAgbWVzc2FnZTogJ1plcm8gVHJ1c3QgTW9kZSBkZWFjdGl2YXRlZCAtIHJldHVybmluZyB0byBOb3JtYWwgTW9kZScsXG4gICAgICBzb3VyY2U6ICd6dG0nXG4gICAgfSlcblxuICAgIHNldFplcm9UcnVzdERhdGEoeyB0aHJlYXRMZXZlbDogJ2dyZWVuJyB9KVxuICAgIHNldElzWmVyb1RydXN0TW9kZShmYWxzZSlcbiAgICBzZXRJc1Bhc3NrZXlWZXJpZmllZChmYWxzZSlcbiAgICBzZXRBY3RpdmVSZWNpcGUoJ0NIQU9TX09OTFknKVxuICAgIHNldFBlbmRpbmdSZWNpcGUobnVsbClcbiAgICBzZXRMYXN0U3dpdGNoUmVhc29uKG51bGwpXG4gICAgc2V0TGFzdFN3aXRjaFRpbWUobnVsbClcbiAgICBzZXRIZXVyaXN0aWNzKERFRkFVTFRfSEVVUklTVElDUylcblxuICAgIGNvbnNvbGUubG9nKCdbWmVybyBUcnVzdF0g4pyFIE1vZGUgZGVhY3RpdmF0ZWQsIGFsbCBkYXRhIGRlc3Ryb3llZCcpXG4gIH0sIFtzZW5kTWVzc2FnZV0pXG5cbiAgLy8gU3dpdGNoIHJlY2lwZVxuICBjb25zdCBzd2l0Y2hSZWNpcGUgPSB1c2VDYWxsYmFjaygocmVjaXBlOiBaVE1SZWNpcGVLZXksIHJlYXNvbj86IHN0cmluZykgPT4ge1xuICAgIC8vIENvb2xkb3duIGNoZWNrICg1IHNlY29uZHMgbWluaW11bSlcbiAgICBpZiAobGFzdFN3aXRjaFRpbWUgJiYgRGF0ZS5ub3coKSAtIGxhc3RTd2l0Y2hUaW1lIDwgNTAwMCkge1xuICAgICAgYWRkRXZlbnRMb2coe1xuICAgICAgICB0eXBlOiAnd2FybmluZycsXG4gICAgICAgIG1lc3NhZ2U6ICdSZWNpcGUgc3dpdGNoIGJsb2NrZWQgLSBjb29sZG93biBhY3RpdmUgKDVzIG1pbmltdW0pJyxcbiAgICAgICAgc291cmNlOiAnenRtJ1xuICAgICAgfSlcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHN3aXRjaFJlYXNvbiA9IHJlYXNvbiB8fCBgTWFudWFsIHN3aXRjaCB0byAke3JlY2lwZX1gXG4gICAgLy8gRG8gbm90IGltbWVkaWF0ZWx5IGNsYWltIHRoZSByZWNpcGUgaXMgYWN0aXZlOyB3YWl0IGZvciBFU1AzMiBjb25maXJtYXRpb25cbiAgICBzZXRQZW5kaW5nUmVjaXBlKHJlY2lwZSlcbiAgICBzZXRMYXN0U3dpdGNoUmVhc29uKHN3aXRjaFJlYXNvbilcbiAgICBzZXRMYXN0U3dpdGNoVGltZShEYXRlLm5vdygpKVxuXG4gICAgc2VuZE1lc3NhZ2Uoe1xuICAgICAgdHlwZTogJ2FkYXB0aXZlX3N3aXRjaF9yZXF1ZXN0JyxcbiAgICAgIG1vZGU6ICd6dG0nLFxuICAgICAgcmVjaXBlOiByZWNpcGUudG9VcHBlckNhc2UoKSAgLy8gU2VydmVyIGV4cGVjdHMgdXBwZXJjYXNlOiBDSEFPU19PTkxZLCBTQUxTQV9MSUdIVCwgZXRjLlxuICAgIH0pXG5cbiAgICBhZGRFdmVudExvZyh7XG4gICAgICB0eXBlOiAncmVjaXBlX3N3aXRjaCcsXG4gICAgICBtZXNzYWdlOiBgU3dpdGNoIHJlcXVlc3RlZCDihpIgJHtyZWNpcGV9OiAke3N3aXRjaFJlYXNvbn1gLFxuICAgICAgc291cmNlOiAnenRtJyxcbiAgICAgIGRldGFpbHM6IHsgcmVjaXBlLCByZWFzb246IHN3aXRjaFJlYXNvbiwgcGVuZGluZzogdHJ1ZSB9XG4gICAgfSlcblxuICAgIGNvbnNvbGUubG9nKGBbWmVybyBUcnVzdF0g4pqhIFJlY2lwZSBzd2l0Y2hlZCB0byAke3JlY2lwZX06ICR7c3dpdGNoUmVhc29ufWApXG4gIH0sIFtsYXN0U3dpdGNoVGltZSwgc2VuZE1lc3NhZ2VdKVxuXG4gIC8vIFVwZGF0ZSBoZXVyaXN0aWNzXG4gIGNvbnN0IHVwZGF0ZUhldXJpc3RpY3MgPSB1c2VDYWxsYmFjaygobWV0cmljczogUGFydGlhbDxIZXVyaXN0aWNNZXRyaWNzPikgPT4ge1xuICAgIHNldEhldXJpc3RpY3MocHJldiA9PiAoeyAuLi5wcmV2LCAuLi5tZXRyaWNzIH0pKVxuICB9LCBbXSlcblxuICAvLyBUcmFjayBsYXN0IHRocmVzaG9sZCBjaGVjayB0byBhdm9pZCBkdXBsaWNhdGUgYWxlcnRzXG4gIGNvbnN0IGxhc3RUaHJlc2hvbGRDaGVjayA9IHVzZVJlZjxudW1iZXI+KDApXG5cbiAgLy8gQ2hlY2sgdGhyZXNob2xkcyBvbiBoZXVyaXN0aWNzIGNoYW5nZSAtIHdvcmtzIGluIEJPVEggTm9ybWFsIGFuZCBaVE0gbW9kZXNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpXG4gICAgLy8gT25seSBjaGVjayBldmVyeSAyIHNlY29uZHMgdG8gcHJldmVudCBzcGFtXG4gICAgaWYgKG5vdyAtIGxhc3RUaHJlc2hvbGRDaGVjay5jdXJyZW50IDwgMjAwMCkgcmV0dXJuXG4gICAgbGFzdFRocmVzaG9sZENoZWNrLmN1cnJlbnQgPSBub3dcblxuICAgIC8vIENoZWNrIHRocmVzaG9sZHMgYWdhaW5zdCBjdXJyZW50IGhldXJpc3RpY3NcbiAgICBjb25zdCB0cmlnZ2VycyA9IGNoZWNrVGhyZXNob2xkcyhoZXVyaXN0aWNzIGFzIFRocmVzaG9sZE1ldHJpY3MpXG5cbiAgICBmb3IgKGNvbnN0IHRyaWdnZXIgb2YgdHJpZ2dlcnMpIHtcbiAgICAgIC8vIENoZWNrIGNvb2xkb3duIHRvIHByZXZlbnQgZHVwbGljYXRlIGFsZXJ0c1xuICAgICAgaWYgKCFjYW5UcmlnZ2VyQWxlcnQodHJpZ2dlci5wcm9maWxlLm5hbWUsIHRyaWdnZXIucHJvZmlsZS5jb29sZG93blNlY29uZHMpKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIEdlbmVyYXRlIGFsZXJ0ICh3b3JrcyBpbiBib3RoIG1vZGVzKVxuICAgICAgY29uc3QgbmV3QWxlcnQ6IFRocmVhdEFsZXJ0ID0ge1xuICAgICAgICBpZDogYGFsZXJ0LSR7RGF0ZS5ub3coKX0tJHtNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwgOSl9YCxcbiAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgICB0eXBlOiB0cmlnZ2VyLnByb2ZpbGUuc2V2ZXJpdHksXG4gICAgICAgIGF0dGFja1R5cGU6IHRyaWdnZXIucHJvZmlsZS5kaXNwbGF5TmFtZSxcbiAgICAgICAgbWVzc2FnZTogdHJpZ2dlci5wcm9maWxlLnJlYXNvbixcbiAgICAgICAgbWV0cmljOiB0cmlnZ2VyLm1ldHJpYyxcbiAgICAgICAgdmFsdWU6IHRyaWdnZXIudmFsdWUsXG4gICAgICAgIHRocmVzaG9sZDogdHJpZ2dlci50aHJlc2hvbGQsXG4gICAgICAgIHJlY2lwZTogaXNaZXJvVHJ1c3RNb2RlID8gdHJpZ2dlci5wcm9maWxlLnRhcmdldFJlY2lwZSA6IHVuZGVmaW5lZFxuICAgICAgfVxuICAgICAgc2V0QWxlcnRzKHByZXYgPT4gW25ld0FsZXJ0LCAuLi5wcmV2XS5zbGljZSgwLCA1MCkpXG5cbiAgICAgIC8vIExvZyB0aGUgYWxlcnRcbiAgICAgIGFkZEV2ZW50TG9nKHtcbiAgICAgICAgdHlwZTogJ3RocmVhdCcsXG4gICAgICAgIG1lc3NhZ2U6IGAke3RyaWdnZXIucHJvZmlsZS5kaXNwbGF5TmFtZX06ICR7dHJpZ2dlci5wcm9maWxlLnJlYXNvbn1gLFxuICAgICAgICBzb3VyY2U6IGlzWmVyb1RydXN0TW9kZSA/ICd6dG0nIDogJ3N5c3RlbScsXG4gICAgICAgIGRldGFpbHM6IHtcbiAgICAgICAgICBtZXRyaWM6IHRyaWdnZXIubWV0cmljLFxuICAgICAgICAgIHZhbHVlOiB0cmlnZ2VyLnZhbHVlLFxuICAgICAgICAgIHRocmVzaG9sZDogdHJpZ2dlci50aHJlc2hvbGQsXG4gICAgICAgICAgbW9kZTogaXNaZXJvVHJ1c3RNb2RlID8gJ1pUTScgOiAnTk9STUFMJ1xuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgICAvLyBPbmx5IGF1dG8tc3dpdGNoIHJlY2lwZSBpbiBaVE0gbW9kZVxuICAgICAgaWYgKGlzWmVyb1RydXN0TW9kZSAmJiB0cmlnZ2VyLnByb2ZpbGUudGFyZ2V0UmVjaXBlKSB7XG4gICAgICAgIHN3aXRjaFJlY2lwZSh0cmlnZ2VyLnByb2ZpbGUudGFyZ2V0UmVjaXBlIGFzIFpUTVJlY2lwZUtleSwgdHJpZ2dlci5wcm9maWxlLnJlYXNvbilcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coYFtBbGVydF0gJHtpc1plcm9UcnVzdE1vZGUgPyAn8J+UtCBaVE0nIDogJ/Cfn6EgTm9ybWFsJ306ICR7dHJpZ2dlci5wcm9maWxlLmRpc3BsYXlOYW1lfWAsIHtcbiAgICAgICAgbWV0cmljOiB0cmlnZ2VyLm1ldHJpYyxcbiAgICAgICAgdmFsdWU6IHRyaWdnZXIudmFsdWUsXG4gICAgICAgIHRocmVzaG9sZDogdHJpZ2dlci50aHJlc2hvbGQsXG4gICAgICAgIGF1dG9Td2l0Y2g6IGlzWmVyb1RydXN0TW9kZVxuICAgICAgfSlcbiAgICB9XG4gIH0sIFtoZXVyaXN0aWNzLCBpc1plcm9UcnVzdE1vZGVdKVxuXG4gIC8vIEFkZCBhbGVydFxuICBjb25zdCBhZGRBbGVydCA9IHVzZUNhbGxiYWNrKChhbGVydDogT21pdDxUaHJlYXRBbGVydCwgJ2lkJyB8ICd0aW1lc3RhbXAnPikgPT4ge1xuICAgIGNvbnN0IG5ld0FsZXJ0OiBUaHJlYXRBbGVydCA9IHtcbiAgICAgIC4uLmFsZXJ0LFxuICAgICAgaWQ6IGBhbGVydC0ke0RhdGUubm93KCl9LSR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDkpfWAsXG4gICAgICB0aW1lc3RhbXA6IERhdGUubm93KClcbiAgICB9XG4gICAgc2V0QWxlcnRzKHByZXYgPT4gW25ld0FsZXJ0LCAuLi5wcmV2XS5zbGljZSgwLCA1MCkpIC8vIEtlZXAgbWF4IDUwIGFsZXJ0c1xuXG4gICAgLy8gQWxzbyBsb2cgdG8gZXZlbnQgbG9nXG4gICAgYWRkRXZlbnRMb2coe1xuICAgICAgdHlwZTogJ3RocmVhdCcsXG4gICAgICBtZXNzYWdlOiBgJHthbGVydC5hdHRhY2tUeXBlfTogJHthbGVydC5tZXNzYWdlfWAsXG4gICAgICBzb3VyY2U6ICd6dG0nLFxuICAgICAgZGV0YWlsczoge1xuICAgICAgICBtZXRyaWM6IGFsZXJ0Lm1ldHJpYyxcbiAgICAgICAgdmFsdWU6IGFsZXJ0LnZhbHVlLFxuICAgICAgICB0aHJlc2hvbGQ6IGFsZXJ0LnRocmVzaG9sZFxuICAgICAgfVxuICAgIH0pXG4gIH0sIFtdKVxuXG4gIGNvbnN0IGRpc21pc3NBbGVydCA9IHVzZUNhbGxiYWNrKChpZDogc3RyaW5nKSA9PiB7XG4gICAgc2V0QWxlcnRzKHByZXYgPT4gcHJldi5maWx0ZXIoYSA9PiBhLmlkICE9PSBpZCkpXG4gIH0sIFtdKVxuXG4gIGNvbnN0IGNsZWFyQWxlcnRzID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIHNldEFsZXJ0cyhbXSlcbiAgfSwgW10pXG5cbiAgLy8gQWRkIGV2ZW50IGxvZ1xuICBjb25zdCBhZGRFdmVudExvZyA9IHVzZUNhbGxiYWNrKChlbnRyeTogT21pdDxMb2dFbnRyeSwgJ2lkJyB8ICd0aW1lc3RhbXAnPikgPT4ge1xuICAgIGNvbnN0IG5ld0VudHJ5OiBMb2dFbnRyeSA9IHtcbiAgICAgIC4uLmVudHJ5LFxuICAgICAgaWQ6IGBsb2ctJHtEYXRlLm5vdygpfS0ke01hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCA5KX1gLFxuICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpXG4gICAgfVxuICAgIHNldEV2ZW50TG9ncyhwcmV2ID0+IFsuLi5wcmV2LCBuZXdFbnRyeV0uc2xpY2UoLTEwMCkpIC8vIEtlZXAgbGFzdCAxMDAgbG9nc1xuICB9LCBbXSlcblxuICBjb25zdCBjbGVhckV2ZW50TG9ncyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBzZXRFdmVudExvZ3MoW10pXG4gIH0sIFtdKVxuXG4gIC8vIExpc3RlbiBmb3IgV2ViU29ja2V0IG1lc3NhZ2VzXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFsYXN0TWVzc2FnZSkgcmV0dXJuXG5cbiAgICBjb25zdCB7IHR5cGUsIC4uLmRhdGEgfSA9IGxhc3RNZXNzYWdlXG5cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ3p0bV9hY3RpdmF0aW9uX2Fja25vd2xlZGdlZCc6XG4gICAgICAgIGlmIChkYXRhLnN1Y2Nlc3MpIHtcbiAgICAgICAgICBzZXRaZXJvVHJ1c3REYXRhKHByZXYgPT4gKHsgLi4ucHJldiwgdGhyZWF0TGV2ZWw6ICdncmVlbicgfSkpXG4gICAgICAgICAgLy8gUHJlZmVyIEVTUDMyLXByb3ZpZGVkIHJlY2lwZSBmaWVsZHMgKGN1cnJlbnRSZWNpcGUvcmVjaXBlKVxuICAgICAgICAgIGNvbnN0IHIgPSAoZGF0YS5jdXJyZW50UmVjaXBlIHx8IGRhdGEucmVjaXBlKSBhcyBzdHJpbmcgfCB1bmRlZmluZWRcbiAgICAgICAgICBpZiAocikge1xuICAgICAgICAgICAgY29uc3QgdXBwZXIgPSBTdHJpbmcocikudG9VcHBlckNhc2UoKVxuICAgICAgICAgICAgaWYgKFsnRlVMTF9TVEFDSycsICdDSEFDSEFfSEVBVlknLCAnU0FMU0FfTElHSFQnLCAnQ0hBT1NfT05MWScsICdTVFJFQU1fRk9DVVMnXS5pbmNsdWRlcyh1cHBlcikpIHtcbiAgICAgICAgICAgICAgc2V0QWN0aXZlUmVjaXBlKHVwcGVyIGFzIFpUTVJlY2lwZUtleSlcbiAgICAgICAgICAgICAgc2V0UGVuZGluZ1JlY2lwZShudWxsKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBhZGRFdmVudExvZyh7XG4gICAgICAgICAgICB0eXBlOiAnc3VjY2VzcycsXG4gICAgICAgICAgICBtZXNzYWdlOiBgWlRNIGFjdGl2YXRpb24gYWNrbm93bGVkZ2VkIChyZWNpcGU9JHsoZGF0YS5jdXJyZW50UmVjaXBlIHx8IGRhdGEucmVjaXBlIHx8ICd1bmtub3duJyl9KWAsXG4gICAgICAgICAgICBzb3VyY2U6ICdzZXJ2ZXInXG4gICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXRQZW5kaW5nUmVjaXBlKG51bGwpXG4gICAgICAgICAgYWRkRXZlbnRMb2coe1xuICAgICAgICAgICAgdHlwZTogJ2Vycm9yJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGBaVE0gYWN0aXZhdGlvbiByZWplY3RlZDogJHtkYXRhLmVycm9yIHx8ICd1bmtub3duIGVycm9yJ31gLFxuICAgICAgICAgICAgc291cmNlOiAnc2VydmVyJ1xuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSAnYWRhcHRpdmVfc3dpdGNoX2Fja25vd2xlZGdlZCc6XG4gICAgICAgIC8vIFRoaXMgaXMgYSBicm9hZGNhc3Q7IHRyZWF0IGFzIGluZm9ybWF0aW9uYWwgKEVTUDMyIHdpbGwgZW1pdCByZWNpcGVfc3dpdGNoZWQgb24gY29tbWl0KVxuICAgICAgICBhZGRFdmVudExvZyh7XG4gICAgICAgICAgdHlwZTogZGF0YS5zdWNjZXNzID09PSBmYWxzZSA/ICd3YXJuaW5nJyA6ICdpbmZvJyxcbiAgICAgICAgICBtZXNzYWdlOiBgU3dpdGNoIGFjayBicm9hZGNhc3Q6IG1vZGU9JHtkYXRhLm1vZGUgfHwgJ3p0bSd9IHJlY2lwZT0ke2RhdGEucmVjaXBlIHx8ICd1bmtub3duJ30gc3VjY2Vzcz0ke2RhdGEuc3VjY2VzcyAhPT0gZmFsc2V9YCxcbiAgICAgICAgICBzb3VyY2U6ICdzZXJ2ZXInXG4gICAgICAgIH0pXG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGNhc2UgJ2hldXJpc3RpY3NfdXBkYXRlJzpcbiAgICAgICAgdXBkYXRlSGV1cmlzdGljcyhkYXRhLm1ldHJpY3MpXG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGNhc2UgJ3RocmVhdF9hbGVydCc6XG4gICAgICAgIGFkZEFsZXJ0KHtcbiAgICAgICAgICB0eXBlOiBkYXRhLnNldmVyaXR5IHx8ICd3YXJuaW5nJyxcbiAgICAgICAgICBhdHRhY2tUeXBlOiBkYXRhLmF0dGFja1R5cGUsXG4gICAgICAgICAgbWVzc2FnZTogZGF0YS5tZXNzYWdlLFxuICAgICAgICAgIG1ldHJpYzogZGF0YS5tZXRyaWMsXG4gICAgICAgICAgdmFsdWU6IGRhdGEudmFsdWUsXG4gICAgICAgICAgdGhyZXNob2xkOiBkYXRhLnRocmVzaG9sZCxcbiAgICAgICAgICByZWNpcGU6IGRhdGEucmVjaXBlU3dpdGNoZWRcbiAgICAgICAgfSlcblxuICAgICAgICAvLyBBdXRvLXN3aXRjaCByZWNpcGUgaW4gWlRNIG1vZGVcbiAgICAgICAgaWYgKGlzWmVyb1RydXN0TW9kZSAmJiBkYXRhLnJlY2lwZVN3aXRjaGVkKSB7XG4gICAgICAgICAgc2V0QWN0aXZlUmVjaXBlKGRhdGEucmVjaXBlU3dpdGNoZWQgYXMgWlRNUmVjaXBlS2V5KVxuICAgICAgICAgIHNldExhc3RTd2l0Y2hSZWFzb24oZGF0YS5yZWFzb24gfHwgJ0F1dG9tYXRpYyB0aHJlYXQgcmVzcG9uc2UnKVxuICAgICAgICAgIHNldExhc3RTd2l0Y2hUaW1lKERhdGUubm93KCkpXG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSAnenRtX3N0YXR1cyc6XG4gICAgICBjYXNlICd6dG1fc3RhdHVzX3VwZGF0ZSc6IHtcbiAgICAgICAgLy8gRVNQMzIgcGVyaW9kaWMvY3VycmVudCBzdGF0dXMgKHNvdXJjZSBvZiB0cnV0aClcbiAgICAgICAgY29uc3QgZW5hYmxlZCA9ICEhZGF0YS56dG1FbmFibGVkXG4gICAgICAgIGNvbnN0IHIgPSAoZGF0YS5jdXJyZW50UmVjaXBlIHx8IGRhdGEucmVjaXBlKSBhcyBzdHJpbmcgfCB1bmRlZmluZWRcbiAgICAgICAgaWYgKGVuYWJsZWQpIHtcbiAgICAgICAgICBzZXRJc1plcm9UcnVzdE1vZGUodHJ1ZSlcbiAgICAgICAgICBpZiAocikge1xuICAgICAgICAgICAgY29uc3QgdXBwZXIgPSBTdHJpbmcocikudG9VcHBlckNhc2UoKVxuICAgICAgICAgICAgaWYgKFsnRlVMTF9TVEFDSycsICdDSEFDSEFfSEVBVlknLCAnU0FMU0FfTElHSFQnLCAnQ0hBT1NfT05MWScsICdTVFJFQU1fRk9DVVMnXS5pbmNsdWRlcyh1cHBlcikpIHtcbiAgICAgICAgICAgICAgLy8gSWYgcmVjaXBlIGFjdHVhbGx5IGNoYW5nZWQsIGxvZyBpdCBhcyBhIGNvbW1pdHRlZCBzd2l0Y2hcbiAgICAgICAgICAgICAgc2V0QWN0aXZlUmVjaXBlKHByZXYgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChwcmV2ICE9PSB1cHBlcikge1xuICAgICAgICAgICAgICAgICAgYWRkRXZlbnRMb2coe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAncmVjaXBlX3N3aXRjaCcsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBSZWNpcGUgY29tbWl0dGVkOiAke3ByZXZ9IOKGkiAke3VwcGVyfWAsXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZTogJ3NlcnZlcicsXG4gICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICBlcG9jaDogZGF0YS5lcG9jaCxcbiAgICAgICAgICAgICAgICAgICAgICByZWFzb246IGRhdGEubGFzdFN3aXRjaFJlYXNvblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgc2V0TGFzdFN3aXRjaFJlYXNvbihkYXRhLmxhc3RTd2l0Y2hSZWFzb24gfHwgYFN3aXRjaGVkIHRvICR7dXBwZXJ9YClcbiAgICAgICAgICAgICAgICAgIHNldExhc3RTd2l0Y2hUaW1lKERhdGUubm93KCkpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB1cHBlciBhcyBaVE1SZWNpcGVLZXlcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgc2V0UGVuZGluZ1JlY2lwZShudWxsKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBJZiBFU1AzMiBzYXlzIGRpc2FibGVkLCByZWZsZWN0IHRoYXQgKGV2ZW4gaWYgVUkgdGhvdWdodCBhY3RpdmUpXG4gICAgICAgICAgc2V0SXNaZXJvVHJ1c3RNb2RlKGZhbHNlKVxuICAgICAgICAgIHNldFBlbmRpbmdSZWNpcGUobnVsbClcbiAgICAgICAgfVxuICAgICAgICBicmVha1xuICAgICAgfVxuXG4gICAgICBjYXNlICdyZWNpcGVfc3dpdGNoZWQnOiB7XG4gICAgICAgIC8vIEVTUDMyIGNvbW1pdCBldmVudCAoYXV0aG9yaXRhdGl2ZSlcbiAgICAgICAgY29uc3QgbmV3UiA9IChkYXRhLm5ld1JlY2lwZSB8fCBkYXRhLnJlY2lwZSB8fCBkYXRhLmN1cnJlbnRSZWNpcGUpIGFzIHN0cmluZyB8IHVuZGVmaW5lZFxuICAgICAgICBjb25zdCBvbGRSID0gKGRhdGEub2xkUmVjaXBlKSBhcyBzdHJpbmcgfCB1bmRlZmluZWRcbiAgICAgICAgY29uc3QgcmVhc29uID0gKGRhdGEucmVhc29uKSBhcyBzdHJpbmcgfCB1bmRlZmluZWRcbiAgICAgICAgaWYgKG5ld1IpIHtcbiAgICAgICAgICBjb25zdCB1cHBlciA9IFN0cmluZyhuZXdSKS50b1VwcGVyQ2FzZSgpXG4gICAgICAgICAgaWYgKFsnRlVMTF9TVEFDSycsICdDSEFDSEFfSEVBVlknLCAnU0FMU0FfTElHSFQnLCAnQ0hBT1NfT05MWScsICdTVFJFQU1fRk9DVVMnXS5pbmNsdWRlcyh1cHBlcikpIHtcbiAgICAgICAgICAgIHNldEFjdGl2ZVJlY2lwZSh1cHBlciBhcyBaVE1SZWNpcGVLZXkpXG4gICAgICAgICAgICBzZXRQZW5kaW5nUmVjaXBlKG51bGwpXG4gICAgICAgICAgICBzZXRMYXN0U3dpdGNoUmVhc29uKHJlYXNvbiB8fCBgU3dpdGNoZWQgdG8gJHt1cHBlcn1gKVxuICAgICAgICAgICAgc2V0TGFzdFN3aXRjaFRpbWUoRGF0ZS5ub3coKSlcbiAgICAgICAgICAgIGFkZEV2ZW50TG9nKHtcbiAgICAgICAgICAgICAgdHlwZTogJ3JlY2lwZV9zd2l0Y2gnLFxuICAgICAgICAgICAgICBtZXNzYWdlOiBgUmVjaXBlIGNvbW1pdHRlZDogJHtvbGRSID8gYCR7b2xkUn0g4oaSIGAgOiAnJ30ke3VwcGVyfSR7cmVhc29uID8gYCAoJHtyZWFzb259KWAgOiAnJ31gLFxuICAgICAgICAgICAgICBzb3VyY2U6ICdlc3AzMidcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG5cbiAgICAgIGNhc2UgJ3NlY3VyaXR5X3VwZGF0ZSc6XG4gICAgICAgIGlmIChkYXRhLmRlY3J5cHRfZmFpbHVyZXMgIT09IHVuZGVmaW5lZCB8fCBkYXRhLmhtYWNfZmFpbHVyZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHVwZGF0ZUhldXJpc3RpY3Moe1xuICAgICAgICAgICAgZGVjcnlwdEZhaWx1cmVzOiBkYXRhLmRlY3J5cHRfZmFpbHVyZXMgfHwgMCxcbiAgICAgICAgICAgIGhtYWNGYWlsdXJlczogZGF0YS5obWFjX2ZhaWx1cmVzIHx8IDAsXG4gICAgICAgICAgICByZXBsYXlBdHRlbXB0czogZGF0YS5yZXBsYXlfYXR0ZW1wdHMgfHwgMFxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSAnZGVjcnlwdGlvbl91cGRhdGUnOlxuICAgICAgICAvLyBFeHRyYWN0IGxpdmUgbGF0ZW5jeSBmcm9tIGFjdHVhbCBkZWNyeXB0aW9uIHRpbWVcbiAgICAgICAgaWYgKGRhdGEuZGVjcnlwdGlvblRpbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHVwZGF0ZUhldXJpc3RpY3Moe1xuICAgICAgICAgICAgbGF0ZW5jeU1zOiBkYXRhLmRlY3J5cHRpb25UaW1lXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgICAvLyBMb2cgdGhlIGRlY3J5cHRpb24gZXZlbnRcbiAgICAgICAgYWRkRXZlbnRMb2coe1xuICAgICAgICAgIHR5cGU6ICdoZWFsdGgnLFxuICAgICAgICAgIG1lc3NhZ2U6IGBEYXRhIGRlY3J5cHRlZCBpbiAke2RhdGEuZGVjcnlwdGlvblRpbWU/LnRvRml4ZWQoMil9bXNgLFxuICAgICAgICAgIHNvdXJjZTogJ3NlcnZlcicsXG4gICAgICAgICAgZGV0YWlsczoge1xuICAgICAgICAgICAgcGxhaW50ZXh0TGVuZ3RoOiBkYXRhLmZpbmFsUGxhaW50ZXh0Py5sZW5ndGhcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGNhc2UgJ2hlYWx0aF9kYXRhX3VwZGF0ZSc6XG4gICAgICAgIC8vIExvZyBoZWFsdGggZGF0YSBmcm9tIEVTUDMyXG4gICAgICAgIGFkZEV2ZW50TG9nKHtcbiAgICAgICAgICB0eXBlOiAnaGVhbHRoJyxcbiAgICAgICAgICBtZXNzYWdlOiBgSGVhbHRoOiBIUj0ke2RhdGEuaGVhcnRSYXRlfSBTUE8yPSR7ZGF0YS5zcG8yfSBTdGVwcz0ke2RhdGEuc3RlcHN9YCxcbiAgICAgICAgICBzb3VyY2U6ICdlc3AzMidcbiAgICAgICAgfSlcbiAgICAgICAgYnJlYWtcbiAgICB9XG4gIH0sIFtsYXN0TWVzc2FnZSwgaXNaZXJvVHJ1c3RNb2RlLCB1cGRhdGVIZXVyaXN0aWNzLCBhZGRBbGVydCwgYWRkRXZlbnRMb2ddKVxuXG4gIGNvbnN0IHZhbHVlOiBaZXJvVHJ1c3RDb250ZXh0VHlwZSA9IHtcbiAgICBpc1plcm9UcnVzdE1vZGUsXG4gICAgaXNQYXNza2V5VmVyaWZpZWQsXG4gICAgdmVyaWZ5UGFzc2tleSxcbiAgICBlbmFibGVaZXJvVHJ1c3QsXG4gICAgZGlzYWJsZVplcm9UcnVzdCxcbiAgICBhY3RpdmVSZWNpcGUsXG4gICAgc3dpdGNoUmVjaXBlLFxuICAgIGxhc3RTd2l0Y2hSZWFzb24sXG4gICAgbGFzdFN3aXRjaFRpbWUsXG4gICAgaGV1cmlzdGljcyxcbiAgICB1cGRhdGVIZXVyaXN0aWNzLFxuICAgIGFsZXJ0cyxcbiAgICBhZGRBbGVydCxcbiAgICBkaXNtaXNzQWxlcnQsXG4gICAgY2xlYXJBbGVydHMsXG4gICAgZXZlbnRMb2dzLFxuICAgIGFkZEV2ZW50TG9nLFxuICAgIGNsZWFyRXZlbnRMb2dzLFxuICAgIHplcm9UcnVzdERhdGFcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgPFplcm9UcnVzdENvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3ZhbHVlfT5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8L1plcm9UcnVzdENvbnRleHQuUHJvdmlkZXI+XG4gIClcbn1cblxuLy8gSG9vayB0byB1c2UgWmVybyBUcnVzdCBjb250ZXh0XG5leHBvcnQgZnVuY3Rpb24gdXNlWmVyb1RydXN0KCk6IFplcm9UcnVzdENvbnRleHRUeXBlIHtcbiAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQoWmVyb1RydXN0Q29udGV4dClcblxuICBpZiAoY29udGV4dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1c2VaZXJvVHJ1c3QgbXVzdCBiZSB1c2VkIHdpdGhpbiBhIFplcm9UcnVzdFByb3ZpZGVyJylcbiAgfVxuXG4gIHJldHVybiBjb250ZXh0XG59XG5cbi8vIEhvb2sgZm9yIHNlY3VyaXR5IG1vbml0b3JpbmcgY29tcG9uZW50c1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVplcm9UcnVzdFNlY3VyaXR5KCkge1xuICBjb25zdCB7IGlzWmVyb1RydXN0TW9kZSwgemVyb1RydXN0RGF0YSwgaGV1cmlzdGljcywgYWxlcnRzIH0gPSB1c2VaZXJvVHJ1c3QoKVxuXG4gIGNvbnN0IGdldFNlY3VyaXR5U3RhdHVzID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBpc0FjdGl2ZTogaXNaZXJvVHJ1c3RNb2RlLFxuICAgICAgdGhyZWF0TGV2ZWw6IHplcm9UcnVzdERhdGEudGhyZWF0TGV2ZWwsXG4gICAgICBhY3RpdmVBbGVydHM6IGFsZXJ0cy5sZW5ndGgsXG4gICAgICBoZXVyaXN0aWNzXG4gICAgfVxuICB9LCBbaXNaZXJvVHJ1c3RNb2RlLCB6ZXJvVHJ1c3REYXRhLnRocmVhdExldmVsLCBhbGVydHMubGVuZ3RoLCBoZXVyaXN0aWNzXSlcblxuICByZXR1cm4ge1xuICAgIHNlY3VyaXR5U3RhdHVzOiBnZXRTZWN1cml0eVN0YXR1cygpLFxuICAgIGlzWmVyb1RydXN0TW9kZSxcbiAgICB6ZXJvVHJ1c3REYXRhLFxuICAgIGhldXJpc3RpY3MsXG4gICAgYWxlcnRzXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgWmVyb1RydXN0Q29udGV4dCJdLCJuYW1lcyI6WyJSZWFjdCIsImNyZWF0ZUNvbnRleHQiLCJ1c2VDb250ZXh0IiwidXNlU3RhdGUiLCJ1c2VDYWxsYmFjayIsInVzZUVmZmVjdCIsInVzZVJlZiIsInVzZVdlYlNvY2tldCIsImNoZWNrVGhyZXNob2xkcyIsImNhblRyaWdnZXJBbGVydCIsIlplcm9UcnVzdENvbnRleHQiLCJ1bmRlZmluZWQiLCJERUZBVUxUX0hFVVJJU1RJQ1MiLCJsYXRlbmN5TXMiLCJlbnRyb3B5QWZ0ZXIiLCJtZW1vcnlQZXJjZW50IiwiY3B1UGVyY2VudCIsImhtYWNGYWlsdXJlcyIsImRlY3J5cHRGYWlsdXJlcyIsInJlcGxheUF0dGVtcHRzIiwibWFsZm9ybWVkUGFja2V0cyIsInRpbWluZ0Fub21hbGllcyIsIlplcm9UcnVzdFByb3ZpZGVyIiwiY2hpbGRyZW4iLCJsYXN0TWVzc2FnZSIsInNlbmRNZXNzYWdlIiwiaXNaZXJvVHJ1c3RNb2RlIiwic2V0SXNaZXJvVHJ1c3RNb2RlIiwiaXNQYXNza2V5VmVyaWZpZWQiLCJzZXRJc1Bhc3NrZXlWZXJpZmllZCIsImFjdGl2ZVJlY2lwZSIsInNldEFjdGl2ZVJlY2lwZSIsInBlbmRpbmdSZWNpcGUiLCJzZXRQZW5kaW5nUmVjaXBlIiwibGFzdFN3aXRjaFJlYXNvbiIsInNldExhc3RTd2l0Y2hSZWFzb24iLCJsYXN0U3dpdGNoVGltZSIsInNldExhc3RTd2l0Y2hUaW1lIiwiaGV1cmlzdGljcyIsInNldEhldXJpc3RpY3MiLCJhbGVydHMiLCJzZXRBbGVydHMiLCJldmVudExvZ3MiLCJzZXRFdmVudExvZ3MiLCJ6ZXJvVHJ1c3REYXRhIiwic2V0WmVyb1RydXN0RGF0YSIsInRocmVhdExldmVsIiwidmVyaWZ5UGFzc2tleSIsInBhc3NrZXkiLCJjb3JyZWN0UGFzc2tleSIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19aVE1fUEFTU0tFWSIsImFkZEV2ZW50TG9nIiwidHlwZSIsIm1lc3NhZ2UiLCJzb3VyY2UiLCJlbmFibGVaZXJvVHJ1c3QiLCJjb25zb2xlIiwibG9nIiwic2Vzc2lvbktleSIsIkFycmF5IiwiZnJvbSIsImxlbmd0aCIsIk1hdGgiLCJmbG9vciIsInJhbmRvbSIsInRvU3RyaW5nIiwicGFkU3RhcnQiLCJqb2luIiwid29yZHMiLCJlcGhlbWVyYWxJZGVudGl0eSIsIkRhdGUiLCJub3ciLCJmaW5hbFBhc3NrZXkiLCJpbml0aWFsUmVjaXBlIiwiZGV0YWlscyIsImRpc2FibGVaZXJvVHJ1c3QiLCJzd2l0Y2hSZWNpcGUiLCJyZWNpcGUiLCJyZWFzb24iLCJzd2l0Y2hSZWFzb24iLCJtb2RlIiwidG9VcHBlckNhc2UiLCJwZW5kaW5nIiwidXBkYXRlSGV1cmlzdGljcyIsIm1ldHJpY3MiLCJwcmV2IiwibGFzdFRocmVzaG9sZENoZWNrIiwiY3VycmVudCIsInRyaWdnZXJzIiwidHJpZ2dlciIsInByb2ZpbGUiLCJuYW1lIiwiY29vbGRvd25TZWNvbmRzIiwibmV3QWxlcnQiLCJpZCIsInN1YnN0ciIsInRpbWVzdGFtcCIsInNldmVyaXR5IiwiYXR0YWNrVHlwZSIsImRpc3BsYXlOYW1lIiwibWV0cmljIiwidmFsdWUiLCJ0aHJlc2hvbGQiLCJ0YXJnZXRSZWNpcGUiLCJzbGljZSIsImF1dG9Td2l0Y2giLCJhZGRBbGVydCIsImFsZXJ0IiwiZGlzbWlzc0FsZXJ0IiwiZmlsdGVyIiwiYSIsImNsZWFyQWxlcnRzIiwiZW50cnkiLCJuZXdFbnRyeSIsImNsZWFyRXZlbnRMb2dzIiwiZGF0YSIsInN1Y2Nlc3MiLCJyIiwiY3VycmVudFJlY2lwZSIsInVwcGVyIiwiU3RyaW5nIiwiaW5jbHVkZXMiLCJlcnJvciIsInJlY2lwZVN3aXRjaGVkIiwiZW5hYmxlZCIsInp0bUVuYWJsZWQiLCJlcG9jaCIsIm5ld1IiLCJuZXdSZWNpcGUiLCJvbGRSIiwib2xkUmVjaXBlIiwiZGVjcnlwdF9mYWlsdXJlcyIsImhtYWNfZmFpbHVyZXMiLCJyZXBsYXlfYXR0ZW1wdHMiLCJkZWNyeXB0aW9uVGltZSIsInRvRml4ZWQiLCJwbGFpbnRleHRMZW5ndGgiLCJmaW5hbFBsYWludGV4dCIsImhlYXJ0UmF0ZSIsInNwbzIiLCJzdGVwcyIsIlByb3ZpZGVyIiwidXNlWmVyb1RydXN0IiwiY29udGV4dCIsIkVycm9yIiwidXNlWmVyb1RydXN0U2VjdXJpdHkiLCJnZXRTZWN1cml0eVN0YXR1cyIsImlzQWN0aXZlIiwiYWN0aXZlQWxlcnRzIiwic2VjdXJpdHlTdGF0dXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./context/ZeroTrustContext.tsx\n"));

/***/ })

});